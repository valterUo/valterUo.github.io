<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>quantum computing | Valter</title>
    <link>https://valteruo.github.io/tag/quantum-computing/</link>
      <atom:link href="https://valteruo.github.io/tag/quantum-computing/index.xml" rel="self" type="application/rss+xml" />
    <description>quantum computing</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Fri, 01 Sep 2023 08:00:00 +0000</lastBuildDate>
    <image>
      <url>https://valteruo.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>quantum computing</title>
      <link>https://valteruo.github.io/tag/quantum-computing/</link>
    </image>
    
    <item>
      <title>The International Workshop on Quantum Data Science and Management (QDSM 2023)</title>
      <link>https://valteruo.github.io/talk/the-international-workshop-on-quantum-data-science-and-management-qdsm-2023/</link>
      <pubDate>Fri, 01 Sep 2023 08:00:00 +0000</pubDate>
      <guid>https://valteruo.github.io/talk/the-international-workshop-on-quantum-data-science-and-management-qdsm-2023/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Quantum Machine Learning: Foundation, New Techniques, and Opportunities for Database Research</title>
      <link>https://valteruo.github.io/publication/sigmod23/</link>
      <pubDate>Thu, 22 Jun 2023 01:00:00 +0000</pubDate>
      <guid>https://valteruo.github.io/publication/sigmod23/</guid>
      <description>&lt;p&gt;See &lt;a href=&#34;https://www.helsinki.fi/en/researchgroups/unified-database-management-systems-udbms/sigmod-2023-tutorial&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tutorial&amp;rsquo;s website&lt;/a&gt; for more details. I will update the paper and more information when they are available.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SQL Query Classification with A Quantum Natural Language Processing Approach</title>
      <link>https://valteruo.github.io/talk/sql-query-classification-with-a-quantum-natural-language-processing-approach/</link>
      <pubDate>Wed, 05 Apr 2023 17:00:00 +0000</pubDate>
      <guid>https://valteruo.github.io/talk/sql-query-classification-with-a-quantum-natural-language-processing-approach/</guid>
      <description>&lt;p&gt;Abstract from &lt;a href=&#34;https://www.uio.no/dscience/english/news-and-events/events/dscience-brain-talk-5.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BrainTalk&amp;rsquo;s website&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;This work proposes a quantum natural language processing-inspired approach for classifying SQL queries based on their execution times and cardinalities. Using parameterized quantum circuits and an iterative method for their optimization, we estimate query metrics by executing optimized circuits on a quantum computer or simulating them. Our results achieve comparable accuracy to previous research in quantum natural language processing, suggesting the potential of this approach in applications beyond quantum natural language processing. We also analyze the model&amp;rsquo;s expressibility and entangling capability histograms for further insights.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quantum Circuit Learning Method for SQL Cardinality, Cost and Time Estimation</title>
      <link>https://valteruo.github.io/talk/quantum-circuit-learning-method-for-sql-cardinality-cost-and-time-estimation/</link>
      <pubDate>Mon, 14 Nov 2022 08:00:00 +0000</pubDate>
      <guid>https://valteruo.github.io/talk/quantum-circuit-learning-method-for-sql-cardinality-cost-and-time-estimation/</guid>
      <description>&lt;p&gt;Structured Query Language (SQL) is the most used relational database query language in the world. In modern applications, data volume, variety, and connectivity have increased. Querying data should not become a bottleneck in data-intensive applications.&lt;/p&gt;
&lt;p&gt;Query processors in relational databases can assign SQL queries to various measurements, such as cardinality, cost, and execution time estimations [1]. The optimization of the query heavily depends on the estimates. Usually, the problem is solved with machine learning, dynamic programming, or integer programming.
Quantum computers are reaching the level where they can be part of various applications on a small scale. We believe that databases and quantum computers will be co-designed in the future so that combinatorically hard database optimization problems can be solved efficiently and with high quality on quantum computers. 
As far as we know, our work is the first attempt to apply quantum computing and quantum circuit learning as a part of the SQL query optimization pipeline. Even if we cannot beat the classical methods with the current quantum hardware, we can point out its limitations, understand quantum computing frameworks in a circuit learning context, and propose novel methods to model the problems with quantum computing algorithms. Especially quantum computing and machine learning are a promising combination because both are based on linear algebra and probability theory.&lt;/p&gt;
&lt;p&gt;We utilize methods from quantum natural language processing (QNLP) [2] and quantum circuit learning [3]. First, we parse SQL queries and represent them using context-free grammar (CFG) diagrams. The CFG diagrams are functorially mapped to pregroup grammar diagrams. We perform a rewriting process for the pregroup grammar diagrams to optimize and reduce their size.  We functorially translated them into parameterized quantum circuits. We will optimize the circuit parameters using standard quantum circuit learning pipelines. A quantum computer or a simulator is used to evaluate the circuit, but the actual training happens on classical hardware.&lt;/p&gt;
&lt;p&gt;This is still ongoing work. Currently, we are at the phase where we can represent SELECT-FROM-WHERE type of SQL queries with complex filtering and join expressions using pregroup grammar diagrams and parametrized circuits. The corresponding results from QNLP are promising. We are excited to be able to express complex SQL queries as parametrized circuits and utilize the quantum circuit learning methods.&lt;/p&gt;
&lt;p&gt;[1] Lan, H., Bao, Z. &amp;amp; Peng, Y. A Survey on Advancing the DBMS Query Optimizer: Cardinality Estimation, Cost Model, and Plan Enumeration. Data Sci. Eng. 6, 86â€“101 (2021). &lt;a href=&#34;https://doi.org/10.1007/s41019-020-00149-7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1007/s41019-020-00149-7&lt;/a&gt;
[2] Meichanetzidis, K., Gogioso, S., De Felice, G., Chiappori, N., Toumi, A., &amp;amp; Coecke, B. (2020). Quantum natural language processing on near-term quantum computers. arXiv preprint arXiv:2005.04147.
[3] Mitarai, K., Negoro, M., Kitagawa, M., &amp;amp; Fujii, K. (2018). Quantum circuit learning. Physical Review A, 98(3), 032309.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Synergy between Quantum Computers and Databases</title>
      <link>https://valteruo.github.io/publication/vldb22_phd_workshop/</link>
      <pubDate>Mon, 05 Sep 2022 01:00:00 +0000</pubDate>
      <guid>https://valteruo.github.io/publication/vldb22_phd_workshop/</guid>
      <description>&lt;p&gt;A short paper that outlines my research connecting quantum computing, databases and category theory.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Studies on Solving Kakuro Puzzle with Grover&#39;s Algorithm</title>
      <link>https://valteruo.github.io/post/classiq_coding_competition_kakuro/</link>
      <pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate>
      <guid>https://valteruo.github.io/post/classiq_coding_competition_kakuro/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.classiq.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Classiq&lt;/a&gt; organized an interesting quantum coding competition in May and June 2022. The competition consisted of four problems: &lt;a href=&#34;https://www.classiq.io/competition/kakuro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kakuro&lt;/a&gt;, &lt;a href=&#34;https://www.classiq.io/competition/toffoli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;decomposing multi-control CNOT gate&lt;/a&gt;, &lt;a href=&#34;https://www.classiq.io/competition/hamiltonian&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hamiltonian simulation&lt;/a&gt; and &lt;a href=&#34;https://www.classiq.io/competition/state-preparation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;log-normal state preparation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This blog post discusses my studies on the Kakuro problem, which should be solved with Grover&amp;rsquo;s algorithm. This problem has been somewhat confusing. If we read the problem definition very carefully, it does not describe what kind of Grover algorithm application it should be. The question is if we are allowed to encode the constraints in Grover&amp;rsquo;s oracle, which is, in my opinion, a lot easier task than writing an oracle that genuinely solves the puzzle.&lt;/p&gt;
&lt;p&gt;I developed three different solutions to the challenge. Again, these solutions did not really meet the judging criteria and were not among the winning solutions. But instead, they study the problem from different angles.&lt;/p&gt;
&lt;p&gt;First, I represent the solution that encodes the variables and values. Instead of using a massive number of qubits, we should design quantum algorithms to take advantage of the exponentially growing state space. Hilbert&amp;rsquo;s space is indeed large, and we should benefit from that. The first solution&amp;rsquo;s downside is that it is not precisely Grover&amp;rsquo;s algorithm that solves the problem. In my opinion, Grover&amp;rsquo;s algorithm instead reads quantumly encoded solution from the black box oracle circuit. The black box oracle circuit is constructed classically. The solution aligns with Grover&amp;rsquo;s original idea of finding the marked element from an unsorted list. Now it depends on the problem definition if this is allowed or not. I developed the solution so you can input any Kakuro problem (not just the one in the Classiq&amp;rsquo;s problem). Then the algorithm classically creates the oracle, and Grover&amp;rsquo;s algorithm &amp;lsquo;&amp;lsquo;reads&amp;rsquo;&amp;rsquo; the solution from the oracle.&lt;/p&gt;
&lt;p&gt;The second solution follows the idea that is also represented in Qiskit documentation: &lt;a href=&#34;https://qiskit.org/textbook/ch-algorithms/grover.html#5.-Solving-Sudoku-using-Grover%27s-Algorithm-&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solving Sudoku using Grover&amp;rsquo;s Algorithm&lt;/a&gt;. I believe that this is the idea that has been in the problem developers&amp;rsquo; minds while designing the Kakuro challenge. Grover&amp;rsquo;s algorithm solves the problem unlike the previous case, but the downside is the circuit&amp;rsquo;s large qubit number and depth. On the other hand, this algorithm is not so interesting because it does not utilize the state space similarly to Grover&amp;rsquo;s original solution.&lt;/p&gt;
&lt;p&gt;I partly participate in the competitions because they motivate me to study new topics. Thus I also want to consider the third option based on an exciting paper: &lt;a href=&#34;https://arxiv.org/abs/1912.04088&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grover Adaptive Search for Constrained Polynomial Binary Optimization&lt;/a&gt;. In this solution, I first encode the Kakuro problem as a quadratic unconstrained binary optimization (QUBO) problem, which could be solved with Grover&amp;rsquo;s algorithm in sufficiently small instances. This is an exciting approach because it differs significantly from the other two solutions. On the other hand, Grover&amp;rsquo;s Adaptive search does not scale well. I demonstrate that D-waves quantum annealers (and Amazon Braket) can solve the problem quickly (without Grover, unfortunately).&lt;/p&gt;
&lt;h2 id=&#34;kakuro-problem&#34;&gt;Kakuro problem&lt;/h2&gt;
&lt;p&gt;The problem is described well in &lt;a href=&#34;https://www.classiq.io/competition/kakuro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Classiq&amp;rsquo;s problem description&lt;/a&gt; and also in &lt;a href=&#34;https://en.wikipedia.org/wiki/Kakuro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wikipedia&lt;/a&gt;. The problem we solve here is assumed to have certain constraints that simplify the problem.&lt;/p&gt;
&lt;h2 id=&#34;transforming-integer-variables-to-binary-variables&#34;&gt;Transforming integer variables to binary variables&lt;/h2&gt;
&lt;p&gt;The notebook utilizes a specific binary variable encoding. Let us assume that we have $n$ variables $x_i$ for $i = 0, \ldots, n - 1$. Now each of these variables can hold a value $0,1,2,3$. In order to express to problem using the binary variables, we define binary variables $x_{i, j}$ so that $i = 0, \ldots, n - 1$ and $j \in \left\{0,1,2,3 \right\}$. The interpretation of the binary variables is simple: $x_{i,j} = 1$ if $x_i = j$. This enables us to encode integers into a binary model. We have $4n$ binary variables in the final model.&lt;/p&gt;
&lt;h2 id=&#34;section-1-solve-problem-classically-and-encode-solution-as-grovers-oracle&#34;&gt;Section 1: Solve problem classically and encode solution as Grover&amp;rsquo;s oracle&lt;/h2&gt;
&lt;p&gt;The first idea to tackle the challenge is to assign a state for each binary variable $x_{i,j}$. In the end, if we measure $x_{i,j} = 1$, we know that $x_i = j$. For example, the variable $x_{0,0}$ can correspond to the state $|0000\rangle$ in the case $n = 4$. Because the number of states grows exponentially, we would be able to represent large problems with a small number of qubits. If we can transform the constraints into Grover oracle, which favors those states that correspond to the problem&amp;rsquo;s solution, this solves the problem.&lt;/p&gt;
&lt;p&gt;This exercise shows me an exciting and confusing point about quantum oracles. Usually, quantum oracles encode the problems that we are solving. Oracles are black-box. In that sense, in this solution proposal, the quantum computer is just a machine that we use to read the result from the oracle.&lt;/p&gt;
&lt;h3 id=&#34;studying-constraint-types&#34;&gt;Studying constraint types&lt;/h3&gt;
&lt;p&gt;We can divide the constraints into two classes. Because I want to be able to code the solution so that anyone, without thinking anything, simply inputs Kakuro constraints from the problem, I start by considering the simple example case from Classiq&amp;rsquo;s problem definition:

$$
\begin{align}
x_0 \neq &amp; x_1 &amp;\quad x_0 \neq&amp; x_2 \\
x_1 \neq &amp; x_3 &amp;\quad x_2 \neq&amp; x_3 \\
x_0 + x_1 =&amp; 3 &amp;\quad x_0 + x_2 =&amp; 3 \\
x_2 + x_3 =&amp; 4 &amp;\quad x_1 + x_3 =&amp; 4.
\end{align}
$$
&lt;/p&gt;
&lt;h4 id=&#34;constraint-type-1-inequality-between-two-variables&#34;&gt;Constraint type 1: inequality between two variables&lt;/h4&gt;
&lt;p&gt;Obviously, the first class of constraints is

$$
\begin{align}
x_0 \neq &amp; x_1 \\
x_2 \neq&amp; x_3 \\
x_0 \neq&amp; x_2 \\
x_1 \neq &amp; x_3.
\end{align}
$$
&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s focus on the first constraint $x_0 \neq x_1$. In the binary variable format, this constraint means that if $x_{i,j} = 1$ then $x_{k,j} = 0$ for $i = 0, 1$, $k = 0, 1$, $i \neq k$ and for $j = 0,1,2,3$. In other words, if we flip the value of the variable $x_{0,j}$ (meaning it is part of the solution), then we are not allowed to flip the variable $x_{1,j}$. If we were to flip the both variables, it would mean $x_0 = j = x_1$, which is not allowed. This analysis shows that we have multiple options for how to flip the binary values of the variables.&lt;/p&gt;
&lt;p&gt;We initially create all the possible correct circuits for the constraint $x_0 \neq x_1$. Then we proceed to the next constraint $x_2 \neq x_3$ and append the possible options to the circuits produced in the previous step. At each appending phase, we check if some previous constraints are violated. If a constraint is violated, we drop the circuit from the process. Finally, we are left with Grover&amp;rsquo;s oracles that produce the correct solution to the problem. Note that this process produces all the correct circuits; for this simple example, there are two.&lt;/p&gt;
&lt;h4 id=&#34;constraint-type-2-sum-of-variables-with-equality-to-constant&#34;&gt;Constraint type 2: sum of variables with equality to constant&lt;/h4&gt;
&lt;p&gt;Clearly, the second class of constraints is

$$
\begin{align}
x_0 + x_1 =&amp; 3 \\
x_2 + x_3 =&amp; 4 \\
x_0 + x_2 =&amp; 3 \\
x_1 + x_3 =&amp; 4.
\end{align}
$$
&lt;/p&gt;
&lt;p&gt;Again, let&amp;rsquo;s focus on the constraint $x_0 + x_1 = 3$. This means that we have two variables whose values sum up to three. We can divide this into multiple cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$x_0 = 0$ and $x_1 = 3$&lt;/li&gt;
&lt;li&gt;$x_0 = 3$ and $x_1 = 0$&lt;/li&gt;
&lt;li&gt;$x_0 = 1$ and $x_1 = 2$&lt;/li&gt;
&lt;li&gt;$x_0 = 2$ and $x_1 = 1$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Luckily variables can hold numbers only up to three, so the maximum value we can face on the right-hand side of the equality is $6$. Also, it is safe to assume that we do not sum more than three variables at the time, and all the variables are different since they appear on the same row or column in the puzzle. This reduces the number of combinations.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s study the case that we want to encode $x_0 = 0$ and $x_1 = 3$. This means that we want to set $x_{0,0} = 1$ and $x_{1,3} = 1$ as binary variables. If we have encoded some constraints before this constraint, flipping the values of these variables might violate some previous constraints. That allows us to drop certain oracles from the construction process. Now we are only left to concretely code this approach.&lt;/p&gt;
&lt;h3 id=&#34;implementation-of-the-first-solution-proposal&#34;&gt;Implementation of the first solution proposal&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import MCXGate, XGate, CCXGate, TGate
import numpy as np
import copy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we concentrate on the main problem, the constraints without any simplification are 

$$
\begin{align}
x_0 &amp;\neq x_1 &amp;\quad x_0 &amp;\neq x_2 &amp;\quad x_1 &amp;\neq x_3 \\
x_1 &amp;\neq x_5 &amp;\quad x_2 &amp;\neq x_3 &amp;\quad x_2 &amp;\neq x_4 \\
x_3 &amp;\neq x_4 &amp;\quad x_3 &amp;\neq x_5 &amp;\quad x_4 &amp;\neq x_6 \\
x_5 &amp;\neq x_6 &amp;&amp;&amp;&amp; \\
x_0 + x_2 &amp;= 5 &amp;\quad x_1 + x_3 + x_5 &amp;= 3 &amp;\quad x_4 + x_6 &amp;= 1 \\
x_2 + x_3 + x_4 &amp;= 5 &amp;\quad x_0 + x_1 &amp;= 3 &amp;\quad x_5 + x_6 &amp;= 1.
\end{align}
$$
&lt;/p&gt;
&lt;p&gt;For four variables, we have $4*4 = 16$ binary variables, which requires $16$ states, so we need exactly four query qubits in Grover&amp;rsquo;s algorithm. For six variables, we need five query qubits. The Classiq&amp;rsquo;s Kakuro puzzle becomes&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;query_qubits = 5
n_variables = 7

inequality_constraints = [(0,1), (0,2), (1,3), (1,5), (2,3), (2,4), (3,4), (3,5), (4,6), (5,6)]
sum_equality_constraints = [{&#39;variables&#39;: [0, 2], &#39;sum&#39;: 5}, 
    {&#39;variables&#39;: [1, 3, 5], &#39;sum&#39;: 3}, 
    {&#39;variables&#39;: [4, 6], &#39;sum&#39;: 1}, 
    {&#39;variables&#39;: [2, 3, 4], &#39;sum&#39;: 5}, 
    {&#39;variables&#39;: [0, 1], &#39;sum&#39;: 3}, 
    {&#39;variables&#39;: [5, 6], &#39;sum&#39;: 1}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following injective function maps the binary variables $x_{i,j}$ to integers whose binary representations correspond to states. We return the binary representation as a list since we will need to access each element in the presentation later.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def variable_to_state(i,j):
    int_repr = 4*i + j
    bin_repr = np.binary_repr(int_repr)
    return &#39;0&#39;*(query_qubits - len(bin_repr)) + bin_repr


def state_to_variable(state):
    decimal = int(state, 2)
    j = decimal % 4
    i = int(np.floor(decimal/4))
    return (i, j)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Encodes if x_3 = 2 i.e. x_3 = 2 is True if |1110&amp;gt; is True after measurement 
print(variable_to_state(3,2))
print(state_to_variable(variable_to_state(3,2)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We proceed with the following idea: Every constraint induces options on how to flip phases. Whatever we include in the circuit, we need to exclude something. Consider the example if $x_{0,1} = 1$ then $x_{1,1} = 0$. When we include the gate that encodes the solution $x_{0,1} = 1$, then we cannot use the gate encoding $x_{1,1} = 1$ at any part of the circuit later. This process reduces the correct oracles.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def compose_phase_flip_gate(i, j, circuit):
    ctrl = variable_to_state(i,j)
    circuit.add(ctrl)
    return circuit


def expand_inequality_oracles(x, y, oracles):
    new_oracles = []
    for oracle in oracles:
        for j in range(4):
            oracle_copy = copy.deepcopy(oracle)
            bin_table = oracle_copy[&#39;bin_table&#39;]
            if bin_table[x][j] != -1 and bin_table[y][j] != 1:
                bin_table[x][j] = 1
                for k in range(4):
                    if k != j:
                        bin_table[x][k] = -1
                bin_table[y][j] = -1
                circuit = oracle_copy[&#39;circuit&#39;]
                compose_phase_flip_gate(x, j, circuit)
                new_oracles.append(oracle_copy)
    return new_oracles


def initialize_oracles(x, y, oracles):
    for j in range(4):
        circuit = compose_phase_flip_gate(x, j, set())
        bin_table = np.zeros(shape=(n_variables, 4))
        bin_table[x][j] = 1
        for k in range(4):
            if k != j:
                bin_table[x][k] = -1
        bin_table[y][j] = -1
        oracles.append({&#39;circuit&#39;: circuit, &#39;bin_table&#39; : bin_table })
    return oracles


def create_inequality_oracles(constraints):
    oracles = []
    x = constraints[0][0]
    y = constraints[0][1]
    oracles = initialize_oracles(x, y, oracles)
    oracles = initialize_oracles(y, x, oracles)
    
    for constraint in constraints[1:]:
        x = constraint[0]
        y = constraint[1]
        oracles = expand_inequality_oracles(x, y, oracles)
        oracles = expand_inequality_oracles(y, x, oracles)
    return oracles
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We run the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;oracles = create_inequality_oracles(inequality_constraints)
print(len(oracles))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following function calculates how many ways we can sum two or three variables to obtain the given sum. We can exclude cases when there are two equal numbers in the sum since these cases will always violate some inequality constraints.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sum_options(constraint):
    variables = constraint[&#39;variables&#39;]
    sum_value = constraint[&#39;sum&#39;]
    result = []
    
    if len(variables) == 2:
        for i in range(4):
            if sum_value - i &amp;lt; 4 and sum_value - i &amp;gt; -1:
                if i != sum_value - i:
                    result.append((i, sum_value - i))
    elif len(variables) == 3:
        for i in range(4):
            if sum_value - i &amp;lt; 4 and sum_value - i &amp;gt; -1:
                options = sum_options({&#39;variables&#39;: [0, 1], &#39;sum&#39;: i})
                for o in options:
                    if (sum_value - i) != o[0] and (sum_value - i) != o[1] and o[0] != o[1]:
                        result.append((sum_value - i, o[0], o[1]))
                        result.append((o[0], sum_value - i, o[1]))
                        result.append((o[0], o[1], sum_value - i))
                
    return list(set(result))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(sum_options({&#39;variables&#39;: [2, 3, 4], &#39;sum&#39;: 3}))
print(sum_options({&#39;variables&#39;: [2, 3, 4], &#39;sum&#39;: 4}))
print(sum_options({&#39;variables&#39;: [2, 3, 4], &#39;sum&#39;: 5}))
print(sum_options({&#39;variables&#39;: [2, 3, 4], &#39;sum&#39;: 6}))

print(sum_options({&#39;variables&#39;: [0, 1], &#39;sum&#39;: 1}))
print(sum_options({&#39;variables&#39;: [0, 1], &#39;sum&#39;: 2}))
print(sum_options({&#39;variables&#39;: [0, 1], &#39;sum&#39;: 3}))
print(sum_options({&#39;variables&#39;: [0, 1], &#39;sum&#39;: 4}))
print(sum_options({&#39;variables&#39;: [0, 1], &#39;sum&#39;: 5}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[(0, 2, 1), (1, 2, 0), (2, 1, 0), (2, 0, 1), (0, 1, 2), (1, 0, 2)]
[(0, 3, 1), (0, 1, 3), (3, 1, 0), (1, 0, 3), (1, 3, 0), (3, 0, 1)]
[(3, 2, 0), (0, 2, 3), (3, 0, 2), (2, 0, 3), (0, 3, 2), (2, 3, 0)]
[(1, 3, 2), (1, 2, 3), (2, 1, 3), (3, 2, 1), (3, 1, 2), (2, 3, 1)]

[(0, 1), (1, 0)]
[(0, 2), (2, 0)]
[(1, 2), (0, 3), (2, 1), (3, 0)]
[(3, 1), (1, 3)]
[(2, 3), (3, 2)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we need to encode the sum constraints. We take the previously generated oracles and modify them. If some constraints are violated, we drop the oracle from the process. Finally, we are left with all the correct oracles that encode the solution to the Kakuro problem.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def limit_oracles_based_on_sum_constraints(sums, constraint, oracles):
    correct_oracles = []
    variables = constraint[&#39;variables&#39;]
    for oracle in oracles:
        for option in sums:
            bin_table = oracle[&#39;bin_table&#39;]
            if all([bin_table[variables[k]][option[k]] == 1 for k in range(len(variables))]):
                correct_oracles.append(oracle)
    return correct_oracles
    

def build_sum_oracle(constraint, oracles):
    sums = sum_options(constraint)
    oracles = limit_oracles_based_on_sum_constraints(sums, constraint, oracles)
    return oracles
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for constraint in sum_equality_constraints:
    oracles = build_sum_oracle(constraint, oracles)
    #print(len(oracles))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code produces some duplicates which can be removed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def remove_duplicates(oracles):
    new_oracles = [oracles[0]]
    for oracle in oracles[1:]:
        if not any([np.array_equal(oracle[&#39;bin_table&#39;], oracle2[&#39;bin_table&#39;]) for oracle2 in new_oracles]):
            new_oracles.append(oracle)
    return new_oracles
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;oracles = remove_duplicates(oracles)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;implement-grover-search&#34;&gt;Implement Grover search&lt;/h3&gt;
&lt;p&gt;Next, we code the standard Grover search.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
import numpy as np
from qiskit import IBMQ, Aer, assemble, transpile
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit.visualization import plot_histogram
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def initialize(qc, qubits):
    qc.x(qubits[-1])
    qc.h(qubits)
    return qc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following function creates the oracle for the correct states.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def compose_grover_oracle(qc, qubits, ctrl_char):
    not_indices = []
    qc.barrier()
    for i, b in enumerate(ctrl_char):
        if b == &#39;0&#39;:
            qc.x(len(qubits) - 2 - i)
            not_indices.append(len(qubits) - 2 - i)
            
    qc.mcx(list(qubits[:-1]), len(qubits) - 1)
    
    for i in not_indices:
        qc.x(i)
    return qc
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def diffusion(qc, qubits):
    qc.barrier()
    qc.h(qubits)
    qc.x(qubits[:-1])
    qc.mcx(list(qubits[:-1]), len(qubits) - 1)
    qc.x(qubits[:-1])
    qc.h(qubits)
    return qc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The algorithm provides all the possible answers to the puzzle. The main Kakuro seems to have just a single solution, but the other example has two solutions. Both are run on a noisy simulator. In both cases, just one oracle call is sufficient.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;final_circuits = []

for oracle in oracles:
    grover_circuit = QuantumCircuit(query_qubits + 1, query_qubits)
    grover_circuit = initialize(grover_circuit, range(query_qubits + 1))
    
    for ctrl_char in oracle[&#39;circuit&#39;]:
        grover_circuit = compose_grover_oracle(grover_circuit, range(query_qubits + 1), ctrl_char)

    grover_circuit = diffusion(grover_circuit, range(query_qubits + 1))
    final_circuits.append(grover_circuit)

final_circuits[0].draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kakuro1&#34; srcset=&#34;
               /post/classiq_coding_competition_kakuro/figure1_hu43558ef56fc0ea93fb961d9f6487769a_21037_acd8e3b7f728641e8a60181b493f7c09.webp 400w,
               /post/classiq_coding_competition_kakuro/figure1_hu43558ef56fc0ea93fb961d9f6487769a_21037_69f95e7a5965191f57c53dc71fb57be2.webp 760w,
               /post/classiq_coding_competition_kakuro/figure1_hu43558ef56fc0ea93fb961d9f6487769a_21037_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_kakuro/figure1_hu43558ef56fc0ea93fb961d9f6487769a_21037_acd8e3b7f728641e8a60181b493f7c09.webp&#34;
               width=&#34;760&#34;
               height=&#34;108&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;solution_counts = []
for grover_circuit in final_circuits:
    grover_circuit.measure(range(query_qubits), range(query_qubits))
    aer_sim = Aer.get_backend(&#39;aer_simulator&#39;, )
    qobj = assemble(grover_circuit)
    result = aer_sim.run(qobj, shots=100000).result()
    counts = result.get_counts()
    solution_counts.append(counts)


legend = [str(i + 1) + &#39;. execution&#39; for i in range(len(solution_counts))]
plot_histogram(solution_counts, legend=legend, sort=&#39;asc&#39;, figsize=(15,12))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kakuro2&#34; srcset=&#34;
               /post/classiq_coding_competition_kakuro/figure2_hu350956b9fa2e7866c34477466f9687f7_28705_f078d4c61ac845a7544a4621e39ea4e7.webp 400w,
               /post/classiq_coding_competition_kakuro/figure2_hu350956b9fa2e7866c34477466f9687f7_28705_a684774ff75f4f88c8ea6a80628bee17.webp 760w,
               /post/classiq_coding_competition_kakuro/figure2_hu350956b9fa2e7866c34477466f9687f7_28705_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_kakuro/figure2_hu350956b9fa2e7866c34477466f9687f7_28705_f078d4c61ac845a7544a4621e39ea4e7.webp&#34;
               width=&#34;760&#34;
               height=&#34;526&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for counts in solution_counts:
    sorted_counts = dict(sorted(counts.items(), key = lambda item: item[1], reverse=True))
    counts_iterator = iter(sorted_counts)
    print(&amp;quot;Possible solution to the Kakuro puzzle: &amp;quot;)
    for i in range(n_variables):
        b = next(counts_iterator)
        (i, j) = state_to_variable(b)
        print(&amp;quot;x_&amp;quot; + str(i) + &amp;quot; = &amp;quot; + str(j))
    print()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;A possible solution to the Kakuro puzzle: 
x_4 = 0
x_3 = 2
x_1 = 1
x_6 = 1
x_0 = 2
x_2 = 3
x_5 = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;decompose-mcx-gates-for-the-actual-kakuro-puzzle&#34;&gt;Decompose MCX gates for the actual Kakuro puzzle&lt;/h3&gt;
&lt;p&gt;The part of the solution can be skipped if you are not interested in reading about gate decompositions.&lt;/p&gt;
&lt;p&gt;The solution above is easy to understand using multi-control Toffoli gates. Still, since we need to follow the original Classiq&amp;rsquo;s problem definition, we must decompose the multi-control Toffoli gates into single qubit and CNOT gates. The evaluation of the circuit is based on the number of the single qubit and CNOT gates. The decomposition is something we already studied in another Classiq&amp;rsquo;s challenge. Since the number of ancilla qubits is not restricted now, we can use &lt;a href=&#34;https://algassert.com/quirk#circuit=%7b%22cols%22:[[%22X%22,%22X%22,%22X%22,%22X%22,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,%22X%22],[1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,%22X%22],[1,1,1,1,%22%E2%80%A2%22,1,1,1,%22X%22],[1,1,1,1,1,1,%22%E2%80%A2%22,1,1,%22X%22],[1,1,1,1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22],[1,1,1,1,1,%22X%22,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22],[1,1,1,1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22],[1,1,1,1,1,1,%22%E2%80%A2%22,1,1,%22X%22],[1,1,1,1,%22%E2%80%A2%22,1,1,1,%22X%22],[1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,%22X%22]]%7d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this simple decomposition&lt;/a&gt;. In the decomposition we still decompose Toffoli-gates. This produces the following code.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def toffoli_decomposed(qc, ctrl_qubits, target):
    first = ctrl_qubits[0]
    second = ctrl_qubits[1]
    
    # I took this decomposition from my solution to multi-control Toffoli challenge
    qc.h(target)
    qc.cx(second, target)
    qc.append(TGate().inverse(), [target])
    qc.cx(first, target)
    qc.append(TGate(), [target])
    qc.cx(first, second)
    qc.cx(second, target)
    qc.cx(first, target)
    qc.append(TGate().inverse(), [second])
    qc.append(TGate().inverse(), [target])
    qc.cx(first, target)
    qc.cx(first, second)
    qc.append(TGate(), [target])
    qc.append(TGate(), [second])
    qc.append(TGate(), [first])
    qc.h(target)
    
    return qc

# This function decomposes Toffoli gate with 5-control qubits
def mcx_5_decomposed(qc, ctrl_qubits, target, ancilla):
    c0, c1, c2 = ctrl_qubits[0], ctrl_qubits[1], ctrl_qubits[2]
    c3, c4 = ctrl_qubits[3], ctrl_qubits[4]
    
    qc = toffoli_decomposed(qc, [c0, c1], ancilla[0])
    #qc.mcx([c0, c1], ancilla[0])
    qc = toffoli_decomposed(qc, [c2, c3], ancilla[1])
    #qc.mcx([c2, c3], ancilla[1])
    qc.cnot(c4, ancilla[2])
    
    qc.cnot(ancilla[0], ancilla[3])
    qc = toffoli_decomposed(qc, [ancilla[1], ancilla[2]], ancilla[4])
    #qc.mcx([ancilla[1], ancilla[2]], ancilla[4])
    
    qc = toffoli_decomposed(qc, [ancilla[3], ancilla[4]], target[0])
    #qc.mcx([ancilla[3], ancilla[4]], target[0])
    
    qc = toffoli_decomposed(qc, [ancilla[1], ancilla[2]], ancilla[4])
    #qc.mcx([ancilla[1], ancilla[2]], ancilla[4])
    qc.cnot(ancilla[0], ancilla[3])
    qc.cnot(c4, ancilla[2])
    qc = toffoli_decomposed(qc, [c2, c3], ancilla[1])
    #qc.mcx([c2, c3], ancilla[1])
    qc = toffoli_decomposed(qc, [c0, c1], ancilla[0])
    #qc.mcx([c0, c1], ancilla[0])
     
    return qc
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def compose_grover_oracle2(qc, query_qubits, target_qubit, ancilla_qubits, ctrl_char):
    not_indices = []
    qc.barrier()
    for i, b in enumerate(ctrl_char):
        if b == &#39;0&#39;:
            qc.x(query_qubits[len(query_qubits) - i - 1])
            not_indices.append(len(query_qubits) - i - 1)
    
    mcx_5_decomposed(qc, query_qubits, target_qubit, ancilla_qubits)
    
    for i in not_indices:
        qc.x(query_qubits[i])
        
    return qc
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if query_qubits == 5:    
    final_circuits = []

    for oracle in oracles:
        
        ancialla_reg = QuantumRegister(5, name = &#39;ancilla&#39;) 
        query_reg = QuantumRegister(query_qubits, name = &#39;query&#39;)
        target_reg = QuantumRegister(1, name = &#39;target&#39;)
        classical_reg = ClassicalRegister(query_qubits)
        
        grover_circuit = QuantumCircuit(query_reg, target_reg, ancialla_reg, classical_reg)
        
        grover_circuit.h(query_reg)
        grover_circuit.x(target_reg)
        grover_circuit.h(target_reg)

        for ctrl_char in oracle[&#39;circuit&#39;]:
            grover_circuit = compose_grover_oracle2(grover_circuit, query_reg, target_reg, ancialla_reg, ctrl_char)

        grover_circuit.barrier()
        grover_circuit.h(query_reg)
        grover_circuit.h(target_reg)
        grover_circuit.x(query_reg)
        grover_circuit.mcx(query_reg, target_reg[0])
        grover_circuit.x(query_reg)
        grover_circuit.h(query_reg)
        grover_circuit.h(target_reg)
        
        final_circuits.append(grover_circuit)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following code visualizes the circuit, but now it is quite long.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;final_circuits[0].draw(output = &#39;mpl&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we run the code on the simulator and ensure that the decomposition is correct.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;solution_counts = []
for grover_circuit in final_circuits:
    grover_circuit.measure(range(query_qubits), range(query_qubits))
    aer_sim = Aer.get_backend(&#39;aer_simulator&#39;)
    qobj = assemble(grover_circuit)
    result = aer_sim.run(qobj, shots=100000).result()
    counts = result.get_counts()
    solution_counts.append(counts)


legend = [str(i + 1) + &#39;. execution&#39; for i in range(len(solution_counts))]
plot_histogram(solution_counts, legend=legend, sort=&#39;asc&#39;, figsize=(15,12))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kakuro3&#34; srcset=&#34;
               /post/classiq_coding_competition_kakuro/figure3_hucb1f40c29e8b69a98026f380a3b0a21c_29030_6b7470bfafd593dbe7a2bfc93a572fde.webp 400w,
               /post/classiq_coding_competition_kakuro/figure3_hucb1f40c29e8b69a98026f380a3b0a21c_29030_3c676cf3c0b9c5d32c6c112981e53a92.webp 760w,
               /post/classiq_coding_competition_kakuro/figure3_hucb1f40c29e8b69a98026f380a3b0a21c_29030_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_kakuro/figure3_hucb1f40c29e8b69a98026f380a3b0a21c_29030_6b7470bfafd593dbe7a2bfc93a572fde.webp&#34;
               width=&#34;760&#34;
               height=&#34;526&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for counts in solution_counts:
    sorted_counts = dict(sorted(counts.items(), key = lambda item: item[1], reverse=True))
    counts_iterator = iter(sorted_counts)
    print(&amp;quot;Possible solution to the Kakuro puzzle: &amp;quot;)
    for i in range(n_variables):
        b = next(counts_iterator)
        (i, j) = state_to_variable(b)
        #print(i,j)
        print(&amp;quot;x_&amp;quot; + str(i) + &amp;quot; = &amp;quot; + str(j))
    print()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;A possible solution to the Kakuro puzzle: 
x_5 = 0
x_6 = 1
x_4 = 0
x_3 = 2
x_0 = 2
x_2 = 3
x_1 = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Statistics about the final decomposed circuit. We can now easily count the 371 CNOT gates in the oracle.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;final_circuits[0].qasm(filename = &#39;kakuro_qasm&#39;)
print(&#39;Gate counts: &#39;, final_circuits[0].count_ops())
print(&#39;Depth: &#39;, final_circuits[0].depth())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Gate counts:  OrderedDict([(&#39;cx&#39;, 371), (&#39;t&#39;, 196), (&#39;tdg&#39;, 147), (&#39;h&#39;, 116), (&#39;x&#39;, 51), (&#39;barrier&#39;, 8), (&#39;measure&#39;, 5), (&#39;mcx_gray&#39;, 1)])
Depth:  371
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;section-2-true-quantum-solution-with-idea-from-qiskit-documentation&#34;&gt;Section 2: True quantum solution with idea from Qiskit documentation&lt;/h2&gt;
&lt;p&gt;In this case, we encode the problem using the same binary variables. Following the idea in the &lt;a href=&#34;https://qiskit.org/textbook/ch-algorithms/grover.html#sudoku&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Qiskit documentation&lt;/a&gt;, we can note that the fact $x_0 \neq x_1$ in decimals is equivalent to the fact $x_{0,j} \neq x_{1,j}$ for all $j = 0,1,2,3$ in binary variables. The documentation gives us the following simple circuit that encodes this inequality for each $j = 0, 1, 2, 3$. The idea is that the ancilla qubit is true if one of the variables is true. If both are true, then the ancilla is false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;qr = QuantumRegister(2, &#39;x&#39;)
anc = QuantumRegister(1, &#39;ancilla&#39;)
circuit = QuantumCircuit(qr, anc)

circuit.cx(0, 2)
circuit.cx(1, 2)

circuit.draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kakuro4&#34; srcset=&#34;
               /post/classiq_coding_competition_kakuro/figure4_hue56e43bd623d64235ff69d1e41bacd94_3527_2747ad2f32de05977a9dd9534373b4df.webp 400w,
               /post/classiq_coding_competition_kakuro/figure4_hue56e43bd623d64235ff69d1e41bacd94_3527_e5a71189fa5bd48bea88285b0025dfff.webp 760w,
               /post/classiq_coding_competition_kakuro/figure4_hue56e43bd623d64235ff69d1e41bacd94_3527_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_kakuro/figure4_hue56e43bd623d64235ff69d1e41bacd94_3527_2747ad2f32de05977a9dd9534373b4df.webp&#34;
               width=&#34;202&#34;
               height=&#34;86&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;For simplicity, let us concentrate on Classiq&amp;rsquo;s specific Kakuro puzzle and not work as general level as in the first case. I used all ten constraints in the below case without manually reducing the number. In the ancilla qubits, the first index (0-9) refers to the inequality constraint, and the second index refers to the value restricting the constraint.&lt;/p&gt;
&lt;p&gt;Then we encode the sums. The idea behind sums is the following: for example, variables $x_2$, $x_3$, $x_4$ can be summed to $5$ with $x_2 = 2$, $x_3 = 3$, $x_4 = 0$. This means that we have the valid case where the binary variables $x_{2,2} = 1$, $x_{3,3} = 1$ and $x_{4,0} = 1$. Each of these binary variables corresponds to a qubit in the above circuit. Thus we can encode this constraint by adding a 3-control qubit Toffoli gate controlled by the qubits corresponding to the variables $x_{2,2}$, $x_{3,3}$ and $x_{4,0}$. That process creates the following circuit. When we mirror the gates to the other side of the last multi-control CNOT gate, we obtain the circuit that works as Grover&amp;rsquo;s oracle. Unfortunately, it is again too large that we could execute it. This approach feels like a waste of qubits, but I cannot develop how to encode similar ideas to phases and use states as in the first solution proposal.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pennylane as qml
from pennylane import numpy as np

sums = []
for c in sum_equality_constraints:
    sums += sum_options(c)

variable_qubits = [&#39;x&#39; + str(i) + str(j) + &#39;  &#39; for i in range(n_variables) for j in range(4)]
inequality_ancillas = [&#39;i_anc&#39; + str(i) + str(j) + &#39;     &#39; for i in range(len(inequality_constraints)) for j in range(4)]
sum_ancillas = [&#39;s_anc&#39; + str(i) + &#39;     &#39; for i in range(len(sums))]
n_ancilla = len(inequality_ancillas) + len(sum_ancillas)
workwires_for_pennylane = [&#39;qml_wire&#39; + str(i) + &#39;     &#39; for i in range(10)]
targets = variable_qubits + inequality_ancillas + sum_ancillas+ [&#39;main_anc&#39;] + workwires_for_pennylane

# The circuit is so large that Pennylane&#39;s built-in devices did not seem to work
# because they are creating some large matrices. Maybe this can be avoided.
# Anyway, Cirq and Braket seem to work fine

dev = qml.device(&#39;cirq.simulator&#39;, wires = targets)
#dev = qml.device(&#39;braket.local.qubit&#39;, wires = targets)

def variables_to_wires(i, j):
    return 4*i + j


def inequality_constraint_circuit(inequality_constraints):
    for i, c in enumerate(inequality_constraints):
        x, y = c[0], c[1]
        for j in range(4):
            x_wire = variables_to_wires(x, j)
            y_wire = variables_to_wires(y, j)
            target_ancilla = inequality_ancillas[4*i + j]
            qml.CNOT(wires = [variable_qubits[x_wire], target_ancilla])
            qml.CNOT(wires = [variable_qubits[y_wire], target_ancilla])
    
    
def inequality_constraint_circuit_reverse(inequality_constraints):
    for i, c in reversed(list(enumerate(inequality_constraints))):
        x, y = c[0], c[1]
        for j in reversed(range(4)):
            x_wire = variables_to_wires(x, j)
            y_wire = variables_to_wires(y, j)
            target_ancilla = inequality_ancillas[4*i + j]
            qml.CNOT(wires = [variable_qubits[x_wire], target_ancilla])
            qml.CNOT(wires = [variable_qubits[y_wire], target_ancilla])

            
def sum_constraint_circuit(sum_equality_constraints):
    ancilla_index = 0
    for c in sum_equality_constraints:
        sums = sum_options(c)
        variables = c[&#39;variables&#39;]
        for sum_option in sums:
            controls = [variable_qubits[variables_to_wires(variables[k], sum_option[k])] for k in range(len(variables))]
            target_ancilla = sum_ancillas[ancilla_index]
            ancilla_index += 1
            qml.MultiControlledX(wires = controls + [target_ancilla], work_wires = workwires_for_pennylane[:2])
            
            
def sum_constraint_circuit_reverse(sum_equality_constraints):
    ancilla_index = len(sum_ancillas) - 1
    for c in reversed(sum_equality_constraints):
        sums = sum_options(c)
        variables = c[&#39;variables&#39;]
        for sum_option in reversed(sums):
            controls = [variable_qubits[variables_to_wires(variables[k], sum_option[k])] for k in range(len(variables))]
            target_ancilla = sum_ancillas[ancilla_index]
            ancilla_index -= 1
            qml.MultiControlledX(wires = controls + [target_ancilla], work_wires = workwires_for_pennylane[2:4])

            
@qml.qnode(dev)
def full_grover_oracle(inequality_constraints, sum_equality_constraints):
    inequality_constraint_circuit(inequality_constraints)
    sum_constraint_circuit(sum_equality_constraints)
    qml.MultiControlledX(wires = inequality_ancillas + sum_ancillas + [&#39;main_anc&#39;])
    sum_constraint_circuit_reverse(sum_equality_constraints)
    inequality_constraint_circuit_reverse(inequality_constraints)
    return qml.state()


qml.drawer.use_style(&#39;black_white&#39;)
fig, ax = qml.draw_mpl(full_grover_oracle, show_all_wires = False)(inequality_constraints, sum_equality_constraints)
fig.set_size_inches(fig.get_size_inches()[0]*0.3, fig.get_size_inches()[1]*0.3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kakuro5&#34; srcset=&#34;
               /post/classiq_coding_competition_kakuro/figure5_hue09a58044857ba687a84b0b2fc8aadcb_326348_908f0a11d67b87d5c1da330f80d50262.webp 400w,
               /post/classiq_coding_competition_kakuro/figure5_hue09a58044857ba687a84b0b2fc8aadcb_326348_ba262a0f9a4d16e8a7379cc343410f66.webp 760w,
               /post/classiq_coding_competition_kakuro/figure5_hue09a58044857ba687a84b0b2fc8aadcb_326348_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_kakuro/figure5_hue09a58044857ba687a84b0b2fc8aadcb_326348_908f0a11d67b87d5c1da330f80d50262.webp&#34;
               width=&#34;760&#34;
               height=&#34;335&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Next, we can insert the previous Grover oracle in Grover&amp;rsquo;s algorithm. One solution to the simulation problem might be to note that the oracle does not implement anything which necessarily requires quantum: it is just a sequence of if-then clauses that flip bits. In this sense, we could take some states (possibly those which we consider relevant: the correct solution and a bunch of false solutions) from the initial distribution and then run the oracle with them. If these states indicate that the predicted right solution has a higher probability of being true after a measurement, we could say that the circuit is correct with high probability.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def apply_grover_oracle():
    inequality_constraint_circuit(inequality_constraints)
    sum_constraint_circuit(sum_equality_constraints)
    qml.MultiControlledX(wires = inequality_ancillas + sum_ancillas + [&#39;main_anc&#39;], work_wires = workwires_for_pennylane[4:8])
    sum_constraint_circuit_reverse(sum_equality_constraints)
    inequality_constraint_circuit_reverse(inequality_constraints)
    
    
def apply_diffusion():
    qml.broadcast(qml.Hadamard, variable_qubits + [&#39;main_anc&#39;], pattern = &#39;single&#39;)
    qml.MultiControlledX(control_wires = variable_qubits, wires = [&#39;main_anc&#39;], control_values = &#39;0&#39;*(len(variable_qubits)), work_wires = workwires_for_pennylane[8:10])
    qml.broadcast(qml.Hadamard, variable_qubits + [&#39;main_anc&#39;], pattern = &#39;single&#39;)

    
@qml.qnode(dev)
def full_grover2():
    qml.PauliX(wires = [&#39;main_anc&#39;])
    qml.broadcast(qml.Hadamard, variable_qubits + [&#39;main_anc&#39;], pattern = &#39;single&#39;)
    apply_grover_oracle()
    apply_diffusion()
    
    return qml.probs(wires = variable_qubits)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following code draws the whole Grover search circuit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;qml.drawer.use_style(&#39;black_white&#39;)
fig, ax = qml.draw_mpl(full_grover2, show_all_wires = False)()
fig.set_size_inches(fig.get_size_inches()[0]*0.3, fig.get_size_inches()[1]*0.3)
print(full_grover2())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;section-3-encode-the-problem-as-qubo-and-solve-it-with-grovers-adaptive-search&#34;&gt;Section 3: Encode the problem as QUBO and solve it with Grover&amp;rsquo;s Adaptive search&lt;/h2&gt;
&lt;h3 id=&#34;encode-constraints-as-qubo&#34;&gt;Encode constraints as QUBO&lt;/h3&gt;
&lt;p&gt;Again, we encode the variables and values using the binary variables $x_{i,j}$. The idea is to define an objective function

$$
f(x) = \sum_{i = 1}^{n}\sum_{j = i + 1}^{n}a_{i,j}x_ix_j + \sum_{i = 1}^{n}b_ix_i,
$$

where $x_i \in \left\{0, 1\right\}$ and $a_{i,j}, b_i\in R$ for $1 \leq i,j \leq n$. When the objective function is constructed to encode the constraints of the Kakuro problem, it heuristically solves the problem. The easiest method to solve the objective is to use quantum annealing but based on the paper &lt;a href=&#34;https://arxiv.org/abs/1912.04088&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grover Adaptive Search for Constrained Polynomial Binary Optimization&lt;/a&gt;, we should be able to solve the problem with a novel application of Grover Search. Since QUBOs are strongly connected to quantum annealing, the most convenient framework to use here is D-wave&amp;rsquo;s Ocean package. We can first test on a quantum annealer that the constructed QUBO encodes the correct problem.&lt;/p&gt;
&lt;p&gt;First, some imports and helper functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import dimod
from dimod.generators.constraints import combinations as qubo_combinations
from dwave.system import LeapHybridSampler
from hybrid.reference import KerberosSampler
from dwave.system.composites import EmbeddingComposite

from braket.aws import AwsDevice
from braket.ocean_plugin import BraketSampler, BraketDWaveSampler

def append_linear_safe(var, val, linear):
    if var in linear.keys():
        linear[var] = linear[var] + val
    else:
        linear[var] = val

def append_quadratic_safe(var, val, quadratic):
    if var in quadratic.keys():
        quadratic[var] = quadratic[var] + val
    else:
        quadratic[var] = val
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;objective-function-for-inequality-constraints&#34;&gt;Objective function for inequality constraints&lt;/h4&gt;
&lt;p&gt;For example, the constraint $x_0 \neq x_1$ means that for any $j = 0,1,2,3$, if $x_{0,j} = 1$ then $x_{1,j} = 0$. In this case the objective function reaches the correct minimum when we add term $x_{0,j}x_{1,j}$ for each $j = 0,1,2,3$. Thus we construct of QUBO which consists of terms as $x_{0,j}x_{1,j}$ encoding the inequality constraints (constraint 1).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def construct_bqm_constraint1(bqm, inequality_constraints):
    vartype = dimod.BINARY
    A = 1
    linear = dict()
    quadratic = dict()
    offset = 0.0

    for c in inequality_constraints:
        x, y = c[0], c[1]
        for j in range(4):
            var1, var2 = (x,j), (y,j)
            append_quadratic_safe((var1, var2), 1, quadratic)

    bqm_c1 = dimod.BinaryQuadraticModel(linear, quadratic, offset, vartype)
    bqm_c1.scale(A)
    bqm.update(bqm_c1)
    return bqm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;objective-function-for-sum-constraints&#34;&gt;Objective function for sum constraints&lt;/h4&gt;
&lt;p&gt;The following formulation follows the facts on how we can divide the sum constraints based on the &lt;code&gt;sum_options&lt;/code&gt; function. Designing this objective function requires manual work because the squared terms need to be opened before we can input them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from itertools import combinations

def construct_bqm_constraint2(bqm, sum_equality_constraints):
    vartype = dimod.BINARY
    A = 10
    linear = dict()
    quadratic = dict()
    offset = 4

    for c in sum_equality_constraints:
        bin_variables = []
        variables = c[&#39;variables&#39;]
        options = sum_options(c)
        
        for i, var in enumerate(variables):
            for o in options:
                bin_variables.append((var, o[i]))
        
        offset = 4
        linear_coefficient = -3   

        if len(variables) == 3:
            offset = 36
            linear_coefficient = -11

        for b in bin_variables:
            append_linear_safe(b, linear_coefficient, linear)

        for comb in combinations(bin_variables, 2):
            append_quadratic_safe(comb, 2, quadratic)

    bqm_c2 = dimod.BinaryQuadraticModel(linear, quadratic, offset, vartype)
    bqm_c2.scale(A)
    bqm.update(bqm_c2)
    return bqm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;additional-constraints&#34;&gt;Additional constraints&lt;/h4&gt;
&lt;p&gt;For every $i$ there is exactly one $j$ so that $x_{i,j} = 1$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def construct_bqm_constraint3(bqm, n_variables):
    strength = 40.0
    for x in range(n_variables):
        variables = [(x, j) for j in range(4)]
        bqm3 = qubo_combinations(variables, 1, strength=strength)
        bqm.update(bqm3)
    return bqm
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;demonstration-of-minimizing-objective-function-with-amazon-braket-d-wave-leap-and-local-machine&#34;&gt;Demonstration of minimizing objective function with Amazon Braket, D-wave Leap, and local machine&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;vartype = dimod.BINARY
bqm = dimod.BinaryQuadraticModel({}, {}, 0.0, vartype)

bqm = construct_bqm_constraint1(bqm, inequality_constraints)
bqm = construct_bqm_constraint2(bqm, sum_equality_constraints)
bqm = construct_bqm_constraint3(bqm, n_variables)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def solve_bqm_in_Amazon_Braket(bqm, system = &amp;quot;Advantage&amp;quot;):
    device = None
    num_reads = 10000
    if system == &amp;quot;Advantage&amp;quot;:
        device = &amp;quot;arn:aws:braket:::device/qpu/d-wave/Advantage_system4&amp;quot;
    elif system == &amp;quot;2000Q&amp;quot;:
        device = &amp;quot;arn:aws:braket:::device/qpu/d-wave/DW_2000Q_6&amp;quot;
    sampler = BraketDWaveSampler(device_arn = device)
    sampler = EmbeddingComposite(sampler)
    sampleset = sampler.sample(bqm, num_reads=num_reads)
    sample = sampleset.first.sample
    
    # print timing info for the previous D-Wave job
    print(sampleset.info[&#39;additionalMetadata&#39;][&#39;dwaveMetadata&#39;][&#39;timing&#39;])
    
    return sample
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def solve_exactly(bqm):
    sampler = dimod.ExactSolver()
    sampleset = sampler.sample(bqm)
    sample = sampleset.first.sample
    return sample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we hopefully get the correct result. We run the code on Amazon Braket:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = solve_bqm_in_Amazon_Braket(bqm)

for elem in result:
    if result[elem] == 1:
        print(&#39;x_&#39; + str(elem[0]) + &#39; = &#39; + str(elem[1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{&#39;qpuSamplingTime&#39;: 1429400, &#39;qpuAnnealTimePerSample&#39;: 20, &#39;qpuAccessTime&#39;: 1444466, &#39;qpuAccessOverheadTime&#39;: 10467, &#39;qpuReadoutTimePerSample&#39;: 102, &#39;qpuProgrammingTime&#39;: 15066, &#39;qpuDelayTimePerSample&#39;: 20, &#39;postProcessingOverheadTime&#39;: 3454, &#39;totalPostProcessingTime&#39;: 29876, &#39;totalRealTime&#39;: None, &#39;runTimeChip&#39;: None, &#39;annealTimePerRun&#39;: None, &#39;readoutTimePerRun&#39;: None}

x_0 = 2
x_1 = 0
x_2 = 3
x_3 = 2
x_4 = 0
x_5 = 1
x_6 = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def solve_bqm_in_leap(bqm, sampler = &amp;quot;Kerberos&amp;quot;):
    bqm.normalize()
    if sampler == &amp;quot;Kerberos&amp;quot;:
        kerberos_sampler = KerberosSampler().sample(bqm, max_iter=10, convergence=3, qpu_params={&#39;label&#39;: &#39;Kakuro puzzle&#39;})
        sample = kerberos_sampler.first.sample
    elif sampler == &amp;quot;LeapHybrid&amp;quot;:
        sampler = LeapHybridSampler()
        sampleset = sampler.sample(bqm)
        sample = sampleset.first.sample
    return sample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With D-wave&amp;rsquo;s Leap, we obtain the correct result as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = solve_bqm_in_leap(bqm, sampler = &amp;quot;LeapHybrid&amp;quot;)

for elem in result:
    if result[elem] == 1:
        print(&#39;x_&#39; + str(elem[0]) + &#39; = &#39; + str(elem[1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&amp;rsquo;t have access to Amazon Braket or D-wave Leap, you can also use the local classical simulated annealing module. Unfortunately, this one is usually relatively slow before we get good results. For example, we had 10 000 num_reads on the quantum computer and 1000 on the local machine. But 1000 shots is not enough for the classical simulated annealing. The quality depends significantly on the parameters, which are sometimes challenging to find (or I have not yet learned).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def solve_with_simulated_annealing(bqm):
    sampler = dimod.SimulatedAnnealingSampler()
    sampleset = sampler.sample(bqm, num_reads=1000)
    sample = sampleset.first.sample
    return sample
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = solve_with_simulated_annealing(bqm)

for elem in result:
    if result[elem] == 1:
        print(&#39;x_&#39; + str(elem[0]) + &#39; = &#39; + str(elem[1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solve-qubo-with-grover-adaptive-search&#34;&gt;Solve QUBO with Grover Adaptive Search&lt;/h3&gt;
&lt;p&gt;The previous example showed how easy it is to solve the problem with quantum annealing. We can be sure that the objective function we found is correct. Next, we study if we can perform something similar to the annealing using Grover&amp;rsquo;s Adaptive Search algorithm. A general version of the algorithm is implemented in &lt;a href=&#34;https://github.com/qiskit/qiskit-optimization&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Qiskit Optimization package&lt;/a&gt;, and a concrete example can be found in the &lt;a href=&#34;https://qiskit.org/documentation/optimization/tutorials/04_grover_optimizer.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grover Optimizer&lt;/a&gt; tutorial.&lt;/p&gt;
&lt;p&gt;I would like to understand the algorithm better, so I started to open and apply the code from &lt;a href=&#34;https://qiskit.org/documentation/_modules/qiskit/circuit/library/arithmetic/quadratic_form.html#QuadraticForm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Source code for qiskit.circuit.library.arithmetic.quadratic_form&lt;/a&gt; and from &lt;a href=&#34;https://github.com/Qiskit/qiskit-optimization/blob/098c167a07e6ed23915ee14c8f3695bf1ced32c4/qiskit_optimization/algorithms/grover_optimizer.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grover_optimizer.py&lt;/a&gt;. This code is in kakuro_GAS_draft notebook. Using the Qiskit Optimization package to solve the obtained QUBO is easy. Unfortunately, the circuit is large again. See the example in the Kakuro_GAS.txt file on &lt;a href=&#34;https://github.com/valterUo/classiq-coding-competition/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;. 100 qubit simulator accepts the optimization problem, but the circuit is too deep, so it could not finish with it. I still believe that the method produces a correct result for the Kakuro puzzle because the objective function is correct. As Braket and Leap analysis showed, Qiskit&amp;rsquo;s GroverOptimizer should work.&lt;/p&gt;
&lt;p&gt;IBM Quantum produces a sort of QASM file of the circuit it runs, and this file is &lt;code&gt;IBM_quantum_GAS_input.json&lt;/code&gt; in this repository. There are 10 827 instructions. GroverOptimizer module does not give easy access to the circuit which optimizes the quadratic program.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from qiskit_optimization import QuadraticProgram
from qiskit import BasicAer
from qiskit_optimization.algorithms import GroverOptimizer
from qiskit.providers.ibmq import least_busy

TOKEN = &amp;quot;add your token&amp;quot;
IBMQ.save_account(TOKEN, overwrite=True)
IBMQ.load_account()
provider = IBMQ.get_provider(hub=&#39;ibm-q&#39;)
backend = provider.get_backend(&#39;simulator_mps&#39;)

qiskit_bqm = QuadraticProgram()

for var in bqm.variables:
    qiskit_bqm.binary_var(str(var))

constant = bqm.offset
linear = []
quadratic = {}

for var in bqm.variables:
    linear.append(bqm.linear[var])
    
for key in bqm.quadratic:
    quadratic[(str(key[0]), str(key[1]))] = bqm.quadratic[key]

qiskit_bqm.minimize(constant = constant, linear=linear, quadratic=quadratic)

grover_optimizer = GroverOptimizer(15, num_iterations=2, quantum_instance=backend)
results = grover_optimizer.solve(qiskit_bqm)

print(&amp;quot;x={}&amp;quot;.format(results.x))
print(&amp;quot;fval={}&amp;quot;.format(results.fval))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The Kakuro puzzle is an exciting problem to be solved on a quantum computer. In this blog post, I studied three different solutions to the puzzles. Although quantum computing solutions suffer from scalability issues, I believe that they are novel approaches to the problem.&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/valterUo/classiq-coding-competition/blob/main/kakuro.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jupyter notebook&lt;/a&gt; contains the code in this blog post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Studies on Multi-controlled CNOT Decompositions</title>
      <link>https://valteruo.github.io/post/classiq_coding_competition_toffoli/</link>
      <pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate>
      <guid>https://valteruo.github.io/post/classiq_coding_competition_toffoli/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.classiq.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Classiq&lt;/a&gt; organized an interesting quantum coding competition in May and June 2022. The competition consisted of four problems: &lt;a href=&#34;https://www.classiq.io/competition/kakuro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kakuro&lt;/a&gt;, &lt;a href=&#34;https://www.classiq.io/competition/toffoli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;decomposing multi-control CNOT gate&lt;/a&gt;, &lt;a href=&#34;https://www.classiq.io/competition/hamiltonian&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hamiltonian simulation&lt;/a&gt; and &lt;a href=&#34;https://www.classiq.io/competition/state-preparation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;log-normal state preparation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this blog post, I represent my studies on the general problem: decomposing the multi-control CNOT gate. Classiq did not consider this solution among the best, but I think it is worth publishing the solution proposal as a blog post. The competition had simple but somewhat strict judging criteria: the best solutions are those which have the shortest circuit depth. Instead of actually concentrating on reaching the minimum circuit depth, I sketched three solutions with different initial conditions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What happens if we perform the decomposition without ancilla qubits?&lt;/li&gt;
&lt;li&gt;What happens when we use ancilla qubits?&lt;/li&gt;
&lt;li&gt;Can we use quantum machine learning to estimate multi-controlled CNOT gates even though we will have some errors?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All my answers are more or less just drafts, but probably, especially the quantum machine learning approach, might be interesting to develop further.&lt;/p&gt;
&lt;p&gt;The original Classiq&amp;rsquo;s problem is decomposing an MCX gate with 14 control qubits into single-qubit and double-qubit CNOT gates using at most five ancilla qubits. This blog post should point out how essential ancilla qubits are in decompositions. For the case when we do not use ancilla qubits, the circuit becomes unpractically long and sometimes impossible to construct. After working on the topic, I thought that ancilla qubits, in some sense, resemble &amp;ldquo;quantum memory.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Because the number 14 in the problem description feels like an arbitrary number for control qubits, the code in this blog post calculates a possible decomposition for any given number of control qubits depending on the user&amp;rsquo;s input. I base the idea on the &lt;a href=&#34;http://csis.pace.edu/~ctappert/cs837-19spring/QC-textbook.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;classical book of Niels and Chuang&lt;/a&gt; and the &lt;a href=&#34;https://algassert.com/circuits/2015/06/22/Using-Quantum-Gates-instead-of-Ancilla-Bits.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;excellent blog post&lt;/a&gt; by Craig Gidney. Also, the paper &lt;a href=&#34;https://arxiv.org/abs/quant-ph/9503016v1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Elementary gates for quantum computation&lt;/a&gt; gives some ideas.&lt;/p&gt;
&lt;p&gt;When facing this kind of problem, maybe everyone first opens the classical book of Niels and Chuang. One can find there the following exercise:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Exercise 4.29: Find a circuit containing $\mathcal{O}(n^2)$ Toffoli, CNOT, and single qubits gates that implement a $C^n(X)$ gate for $n &gt; 3$ using no work qubits.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This exercise appears to be surprisingly deep and hard. It is also connected to the problem in the competition, although it does not include the idea of minimal depth. The &lt;a href=&#34;https://algassert.com/circuits/2015/06/22/Using-Quantum-Gates-instead-of-Ancilla-Bits.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt; by Craig Gidney is about this exercise.&lt;/p&gt;
&lt;p&gt;My contribution is the explanation in this document and the implementation that works for any MCX gate. I completed the implementation with Pennylane because it allows me to code recursive structures easily. I use Qiskit to describe and visualize the method.&lt;/p&gt;
&lt;p&gt;First, we import some needed packages.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json
import pennylane as qml
from pennylane import numpy as np
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import SXGate, SGate, TGate, IGate, MCXGate
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;solution-proposal-without-ancilla-qubits&#34;&gt;Solution proposal without ancilla qubits&lt;/h2&gt;
&lt;h3 id=&#34;square-roots-of-not-gate-and-finding-fundamental-decompositions-with-gidney-niels-and-chuang&#34;&gt;Square roots of NOT gate and finding fundamental decompositions with Gidney, Niels and Chuang&lt;/h3&gt;
&lt;p&gt;As Gidney explains in the &lt;a href=&#34;https://algassert.com/circuits/2015/06/22/Using-Quantum-Gates-instead-of-Ancilla-Bits.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt;, every logical quantum gate has the corresponding square root gate. When we note the fact that diagonal matrices are easy to square and

$$
Z = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; -1
\end{bmatrix},
$$

we obtain that

$$
\sqrt[n]{Z} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\frac{\pi}{n}}
\end{bmatrix}.
$$
&lt;/p&gt;
&lt;p&gt;When we change the computational basis to Hadamard -basis, taking the square roots becomes (at least theoretically) easier: $X = HZH$. That is also why we have Hadamard-gates in the Classiq&amp;rsquo;s example decomposition in the problem description. The $T$-gates and $S$-gates are the certain square roots of $Z$-gate, $T = \sqrt[4]{Z}$ and $S = \sqrt[2]{Z}$. So $T$ and $S$ gates are just a clever way to hide $X$ gates in the decomposition! Gidney reads Niels and Chuang very carefully and notices the power of the following circuit, which corresponds to the Toffoli gate:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qr = QuantumRegister(3)
circuit = QuantumCircuit(qr)

circuit.append(SXGate().control(), [qr[1], qr[2]])
circuit.cx(0, 1)
circuit.append(SXGate().inverse().control(), [qr[1], qr[2]])
circuit.cx(0, 1)
circuit.append(SXGate().control(), [qr[0], qr[2]])

circuit.draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli1&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli1_hu4df9a9dfa3d28739cb72f787bee17960_6170_a02aa4dea1ef24d15d87566bd8ffdfd3.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli1_hu4df9a9dfa3d28739cb72f787bee17960_6170_d0ed55779803413e9f5eff327c7742c0.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli1_hu4df9a9dfa3d28739cb72f787bee17960_6170_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli1_hu4df9a9dfa3d28739cb72f787bee17960_6170_a02aa4dea1ef24d15d87566bd8ffdfd3.webp&#34;
               width=&#34;375&#34;
               height=&#34;117&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;This circuit corresponds to the Toffoli case $V = (1-i)(I+iX)/2$ presented in Figure 4.8 in Niels and Chuang. Furthermore, we can change the basis to Hadamard. Recall that $H\sqrt{X}H = \sqrt{Z} = S$. Thus we can write:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qr = QuantumRegister(3)
circuit = QuantumCircuit(qr)

circuit.h(2)
circuit.append(SGate().control(), [qr[1], qr[2]])
circuit.cx(0, 1)
circuit.append(SGate().inverse().control(), [qr[1], qr[2]])
circuit.cx(0, 1)
circuit.append(SGate().control(), [qr[0], qr[2]])
circuit.h(2)

circuit.draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli2&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli2_hub25ca1e49be51a9314e6e0338875c4c2_5429_6d2832a1fbe1b850e54fd27fbfafc7f1.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli2_hub25ca1e49be51a9314e6e0338875c4c2_5429_e37c0d98eb4588cd73e75d455caa22b2.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli2_hub25ca1e49be51a9314e6e0338875c4c2_5429_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli2_hub25ca1e49be51a9314e6e0338875c4c2_5429_6d2832a1fbe1b850e54fd27fbfafc7f1.webp&#34;
               width=&#34;409&#34;
               height=&#34;93&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;If one wants a more concrete visualization of the circuit, it is easy &lt;a href=&#34;https://algassert.com/quirk#circuit=%7b%22cols%22:[[1,1,%22H%22],[1,%22%E2%80%A2%22,%22Z%5e%C2%BD%22],[%22%E2%80%A2%22,%22X%22],[1,%22%E2%80%A2%22,%22Z%5e-%C2%BD%22],[%22%E2%80%A2%22,%22X%22],[%22%E2%80%A2%22,1,%22Z%5e%C2%BD%22],[1,1,%22H%22]]%7d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;to construct it in Quirk&lt;/a&gt; (which is, by the way, developed by Gidney) and check that it encodes the Toffoli gate. The circuit also encodes the MCX gate when considering the first wire is a bundle of multiple wires.&lt;/p&gt;
&lt;p&gt;But this construction does not fulfill the requirement of exercise 4.9 nor the competition description since the control bits are attached to the square root and $S$ gates which are not allowed. A careful reading of Niels and Chuang solves this problem. We can express the controlled-square root gates (also $S$ gates) above using the following decomposition presented in Figure 4.6 in Niels and Chuang. After all, this decomposition is quite well known and classical result. For an arbitrary unitary gate $U$, which is controlled by a single qubit, the decomposition is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;qr = QuantumRegister(2)
circuit = QuantumCircuit(qr)

# This circuit is just for visualization and the identity 
# gate is simply a place holder for the labels
circuit.append(IGate(label = &amp;quot;C&amp;quot;), [qr[1]])
circuit.cx(0, 1)
circuit.append(IGate(label = &amp;quot;B&amp;quot;), [qr[1]])
circuit.cx(0, 1)
circuit.append(IGate(label = &amp;quot;A&amp;quot;), [qr[1]])
circuit.append(IGate(label = &amp;quot;Z(\\alpha)&amp;quot;), [qr[0]])

circuit.draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli3&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli3_hua341c588fd6e8489f4bcceddc34a914d_5353_ac5e4d282a9b2a504784b6da7f5483b6.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli3_hua341c588fd6e8489f4bcceddc34a914d_5353_f195d6aa1d2c41ed378395e784156116.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli3_hua341c588fd6e8489f4bcceddc34a914d_5353_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli3_hua341c588fd6e8489f4bcceddc34a914d_5353_ac5e4d282a9b2a504784b6da7f5483b6.webp&#34;
               width=&#34;340&#34;
               height=&#34;69&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;where

$$
Z(\alpha) = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\alpha}
\end{bmatrix}
$$

and $Z(\alpha)AXBXC = U$ and $ABC = I$.&lt;/p&gt;
&lt;p&gt;If we compare this construction to Figure 4.9 in Niels and Chuang, we can notice that $A = T$, $B = T^{\dagger}$, $C = I$ and $Z(\alpha) = T$. Now $ABC = TT^{\dagger} = I$ and $e^{(i\alpha)}AXBX = S$. So we can deduce that the following circuit implements the controlled $S$ gate:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;qr = QuantumRegister(2)
circuit = QuantumCircuit(qr)

# This circuit is just for visualization and the identity gate is a placeholder for the labels
circuit.cx(0, 1)
circuit.append(TGate().inverse(), [qr[1]])
circuit.cx(0, 1)
circuit.append(TGate(), [qr[1]])
circuit.append(TGate(), [qr[0]])

circuit.draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli4&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli4_hu4d532ab64599fae00b3f836314b835c2_3719_a24bd475ef072704bf6732bc55cd0a8f.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli4_hu4d532ab64599fae00b3f836314b835c2_3719_c6b9562fe3909eb8a632010cfc042251.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli4_hu4d532ab64599fae00b3f836314b835c2_3719_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli4_hu4d532ab64599fae00b3f836314b835c2_3719_a24bd475ef072704bf6732bc55cd0a8f.webp&#34;
               width=&#34;273&#34;
               height=&#34;63&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;When we substitute the above decomposition into the circuit with controlled $S$ gates, we obtain:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;qr = QuantumRegister(3)
circuit = QuantumCircuit(qr)

circuit.h(2)

# First substitution
# circuit.append(SGate().control(), [qr[1], qr[2]])

circuit.barrier()
circuit.cx(1, 2)
circuit.append(TGate().inverse(), [qr[2]])
circuit.cx(1, 2)
circuit.append(TGate(), [qr[2]])
circuit.append(TGate(), [qr[1]])
circuit.barrier()


circuit.cx(0, 1)

# Second substitution for inverse S
# circuit.append(SGate().inverse().control(), [qr[1], qr[2]])

circuit.barrier()
circuit.append(TGate().inverse(), [qr[1]])
circuit.append(TGate().inverse(), [qr[2]])
circuit.cx(1, 2)
circuit.append(TGate(), [qr[2]])
circuit.cx(1, 2)
circuit.barrier()

circuit.cx(0, 1)

# Third substitution
#circuit.append(SGate().control(), [qr[0], qr[2]])

circuit.barrier()
circuit.cx(0, 2)
circuit.append(TGate().inverse(), [qr[2]])
circuit.cx(0, 2)
circuit.append(TGate(), [qr[2]])
circuit.append(TGate(), [qr[0]])
circuit.barrier()

circuit.h(2)

circuit.draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli5&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli5_hu97122eb899887095c0279f6687418f85_10604_dba79cb07f41b2d7ff52951b2f007666.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli5_hu97122eb899887095c0279f6687418f85_10604_825dceeab1579b515f7574698975986c.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli5_hu97122eb899887095c0279f6687418f85_10604_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli5_hu97122eb899887095c0279f6687418f85_10604_dba79cb07f41b2d7ff52951b2f007666.webp&#34;
               width=&#34;760&#34;
               height=&#34;91&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;which can be simplified to the following circuit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;qr = QuantumRegister(3)
circuit = QuantumCircuit(qr)

circuit.h(2)

circuit.cx(1, 2)
circuit.append(TGate().inverse(), [qr[2]])
circuit.cx(0, 2)
circuit.append(TGate(), [qr[2]])

circuit.cx(0, 1)
circuit.cx(1, 2)
circuit.cx(0, 2)

circuit.append(TGate().inverse(), [qr[1]])
circuit.append(TGate().inverse(), [qr[2]])
circuit.cx(0, 2)
circuit.cx(0, 1)

circuit.append(TGate(), [qr[2]])
circuit.append(TGate(), [qr[1]])
circuit.append(TGate(), [qr[0]])

circuit.h(2)

circuit.draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli6&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli6_hub6c2201bab54627c731c1474964dcb89_9189_7f8174f6636468e5f7f92ce9a288de9b.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli6_hub6c2201bab54627c731c1474964dcb89_9189_7d5dca4ee0f3cacfec14f9f6d8b89bf2.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli6_hub6c2201bab54627c731c1474964dcb89_9189_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli6_hub6c2201bab54627c731c1474964dcb89_9189_7f8174f6636468e5f7f92ce9a288de9b.webp&#34;
               width=&#34;589&#34;
               height=&#34;97&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;We see that the depth of this circuit (&lt;a href=&#34;https://algassert.com/quirk#circuit=%7b%22cols%22:[[%22X%22,%22X%22,%22X%22],[1,1,%22H%22],[1,%22%E2%80%A2%22,%22X%22],[1,1,%22Z%5e-%C2%BC%22],[%22%E2%80%A2%22,1,%22X%22],[1,1,%22Z%5e%C2%BC%22],[%22%E2%80%A2%22,%22X%22],[1,%22%E2%80%A2%22,%22X%22],[%22%E2%80%A2%22,1,%22X%22],[1,%22Z%5e-%C2%BC%22,%22Z%5e-%C2%BC%22],[%22%E2%80%A2%22,1,%22X%22],[%22%E2%80%A2%22,%22X%22],[%22Z%5e%C2%BC%22,%22Z%5e%C2%BC%22,%22Z%5e%C2%BC%22],[1,1,%22H%22]]%7d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;see the circuit in Quirk&lt;/a&gt;) is smaller than the one Niels and Chuang represented but not better than in the Classiq&amp;rsquo;s problem description example. The circuit in the Classiq&amp;rsquo;s problem description has a mistake: the fourth CNOT should be between $q_0$ and $q_2$ not between $q_1$ and $q_2$. The correct circuit is &lt;a href=&#34;https://algassert.com/quirk#circuit=%7b%22cols%22:[[1,1,%22H%22],[1,%22%E2%80%A2%22,%22X%22],[1,1,%22Z%5e-%C2%BC%22],[%22%E2%80%A2%22,1,%22X%22],[1,1,%22Z%5e%C2%BC%22],[1,%22%E2%80%A2%22,%22X%22],[1,%22Z%5e%C2%BC%22,%22Z%5e-%C2%BC%22],[%22%E2%80%A2%22,1,%22X%22],[%22%E2%80%A2%22,%22X%22],[1,1,%22Z%5e%C2%BC%22],[1,%22Z%5e-%C2%BC%22],[%22Z%5e%C2%BC%22,1,%22H%22],[%22%E2%80%A2%22,%22X%22]]%7d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;. The number of gates is the same in all of the circuits.&lt;/p&gt;
&lt;h3 id=&#34;iteratively-and-automatically-decompose-larger-mcx-gates&#34;&gt;Iteratively and automatically decompose larger MCX gates&lt;/h3&gt;
&lt;p&gt;In this section, I code a program that iteratively decomposes MCX gates into the previously represented smaller circuits. The algorithm iteratively removes all the multi-control gates from the circuit expressed in the cell [3]. The circuit in the cell [3] does not draw these wires, but we consider that the first wire is a bundle of control wires. Pennylane supports badly renaming the qubit unitaries. In the following circuit, U gates differ from each other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n_ctrl = 14 #number of control qubits
target = n_ctrl + 1
dev = qml.device(&amp;quot;default.qubit&amp;quot;, wires=target)

def get_square_root_z(n):
    return np.array([[1, 0], [0, np.exp(1j*np.pi/n)]])
    
@qml.qnode(dev)
def multi_Toffoli_step1_circuit(n_control_wires):
    all_ctrl_wires = range(n_control_wires + 1)
    target = n_control_wires + 1
    nth_square_root = target - n_control_wires
    square_root_matrix = None
    
    qml.Hadamard(wires=target)
    for i in all_ctrl_wires[:-1]:
        ctrl_wires = all_ctrl_wires[:-i - 1]
        n_ctrl_wires = len(ctrl_wires)
        square_root_matrix = get_square_root_z(2**i)
        square_root_matrix_inv = np.linalg.inv(square_root_matrix)
        
        qml.MultiControlledX(control_wires = ctrl_wires, wires = n_ctrl_wires)
        qml.ControlledQubitUnitary(square_root_matrix_inv, control_wires = n_ctrl_wires, wires = target)
        qml.MultiControlledX(control_wires = ctrl_wires, wires = n_ctrl_wires)
        qml.ControlledQubitUnitary(square_root_matrix, control_wires = n_ctrl_wires, wires = target)
    
    qml.ControlledQubitUnitary(square_root_matrix, control_wires = 0, wires = target)
    qml.Hadamard(wires=target)
    return qml.state()

qml.drawer.use_style(&#39;black_white&#39;)
fig, ax = qml.draw_mpl(multi_Toffoli_step1_circuit, show_all_wires = True)(n_ctrl)
fig.set_size_inches(fig.get_size_inches()[0]*0.3, fig.get_size_inches()[1]*0.3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli7&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli7_hu13f216dc70c45da7fdec702a13d2ccd7_45137_5da6882b2c2f7986a43348f3cb5597f3.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli7_hu13f216dc70c45da7fdec702a13d2ccd7_45137_a1f8f8a1d009004c58e4f364460d4746.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli7_hu13f216dc70c45da7fdec702a13d2ccd7_45137_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli7_hu13f216dc70c45da7fdec702a13d2ccd7_45137_5da6882b2c2f7986a43348f3cb5597f3.webp&#34;
               width=&#34;760&#34;
               height=&#34;276&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Next, we decompose the controlled U gates. Here we apply the rule from the cell [5]. Again, the cell [5] shows only the first step of the iteration. We implement the step by decomposing &lt;code&gt;qml.ControlledQubitUnitary&lt;/code&gt; in the above code. We can draw the circuit in a less pretty but more informative format to see that the controlled U gates are composed correctly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def controlled_qubit_unitary_decomposed(exponent, n_ctrl_wires, target, adjoint = False):
    square_root_matrix = get_square_root_z(2**exponent)
    square_root_matrix_inv = np.linalg.inv(square_root_matrix)
    
    if adjoint:
        qml.QubitUnitary(square_root_matrix_inv, wires = n_ctrl_wires)
        qml.QubitUnitary(square_root_matrix_inv, wires = target)
        qml.CNOT(wires = [n_ctrl_wires, target])
        qml.QubitUnitary(square_root_matrix, wires = target)
        qml.CNOT(wires = [n_ctrl_wires, target])
    else:
        qml.CNOT(wires = [n_ctrl_wires, target])
        qml.QubitUnitary(square_root_matrix_inv, wires = target)
        qml.CNOT(wires = [n_ctrl_wires, target])
        qml.QubitUnitary(square_root_matrix, wires = target)
        qml.QubitUnitary(square_root_matrix, wires = n_ctrl_wires) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@qml.qnode(dev)
def multi_Toffoli_step2_circuit(n_control_wires):
    all_ctrl_wires = range(n_control_wires + 1)
    target = n_control_wires + 1
    nth_square_root = target - n_control_wires
    square_root_matrix = None
    
    qml.Hadamard(wires=target)
    for i in all_ctrl_wires[:-1]:
        ctrl_wires = all_ctrl_wires[:-i - 1]
        n_ctrl_wires = len(ctrl_wires)
        square_root_matrix = get_square_root_z(2**i)
        
        #qml.Barrier(wires = range(target + 1))
        qml.MultiControlledX(control_wires = ctrl_wires, wires = n_ctrl_wires)
        controlled_qubit_unitary_decomposed(i+1, n_ctrl_wires, target, adjoint = True)
        qml.MultiControlledX(control_wires = ctrl_wires, wires = n_ctrl_wires)
        controlled_qubit_unitary_decomposed(i+1, n_ctrl_wires, target, adjoint = False)
        
    #qml.Barrier(wires = range(target +1))
    controlled_qubit_unitary_decomposed(len(all_ctrl_wires[:-1]), 0, target, adjoint = False)
    qml.Hadamard(wires=target)
    return qml.state()

# One can also visualize the code with matplotlib, but then the QubitUnatires won&#39;t show correctly
# because I was not able to overwrite the default name &#39;U&#39;
# There might be a fix for this visualization problem

#qml.drawer.use_style(&#39;black_white&#39;)
#fig, ax = qml.drawer.draw_mpl(multi_Toffoli_step2_circuit, show_all_wires = True, show_matrices=True)(n_ctrl)
#fig.set_size_inches(fig.get_size_inches()[0]*0.4, fig.get_size_inches()[1]*0.4)

print(qml.drawer.draw(multi_Toffoli_step2_circuit, show_all_wires=True, decimals=5, max_length=250, show_matrices=True)(n_ctrl))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we decompose other MCX gates. Note that this step removed one control qubit, and we still have an MCX gate with 13 control qubits. At each step, the number of required control qubits is reduced by one. This means we recursively execute the above code for each &lt;code&gt;qml.MultiControlledX&lt;/code&gt;. As one can expect, the output circuit is long, but it does not use any ancilla qubits.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def multi_Toffoli_step3_circuit(n_control_wires):
    all_ctrl_wires = range(n_control_wires + 1)
    target = n_control_wires + 1
    nth_square_root = target - n_control_wires
    square_root_matrix = None
    
    qml.Hadamard(wires=target)
    for i in all_ctrl_wires[:-1]:
        ctrl_wires = all_ctrl_wires[:-i - 1]
        n_ctrl_wires = len(ctrl_wires)
        square_root_matrix = get_square_root_z(2**i)
        
        #qml.Barrier(wires = range(target + 1))
        multi_Toffoli_step3_circuit(n_ctrl_wires - 1)
        controlled_qubit_unitary_decomposed(i+1, n_ctrl_wires, target, adjoint = True)
        multi_Toffoli_step3_circuit(n_ctrl_wires - 1)
        controlled_qubit_unitary_decomposed(i+1, n_ctrl_wires, target, adjoint = False)
        
    #qml.Barrier(wires = range(target +1))
    controlled_qubit_unitary_decomposed(len(all_ctrl_wires[:-1]), 0, target, adjoint = False)
    qml.Hadamard(wires=target)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 14-control qubit MCX gate produces such a large circuit that I could not even construct it, so I demonstrate the code with 5-control qubits (which is very long also!).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@qml.qnode(dev)
def multi_Toffoli_final(n_control_wires):
    multi_Toffoli_step3_circuit(n_control_wires)
    return qml.state()

n_ctrl = 5
print(qml.drawer.draw(multi_Toffoli_final, show_all_wires=False, decimals=5, max_length=250, show_matrices=True)(n_ctrl))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even if the circuit is unpractically long to be visualized, we can easily calculate its depth and gate count with Pennylane. The framework also offers other possibly interesting information about the circuit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Also command multi_Toffoli_final.qtape.get_depth() might be useful
n_ctrl = 7
print(&amp;quot;The specs of &amp;quot; + str(n_ctrl) + &amp;quot; control qubits Toffoli gate without ancilla qubits is: &amp;quot;)
print(json.dumps(qml.specs(multi_Toffoli_final)(n_ctrl), indent=4, sort_keys=True))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;The specs of 7 control qubits Toffoli gate without ancilla qubits is: 
{
    &amp;quot;depth&amp;quot;: 17012,
    &amp;quot;device_name&amp;quot;: &amp;quot;default.qubit.autograd&amp;quot;,
    &amp;quot;diff_method&amp;quot;: &amp;quot;best&amp;quot;,
    &amp;quot;expansion_strategy&amp;quot;: &amp;quot;gradient&amp;quot;,
    &amp;quot;gate_sizes&amp;quot;: {
        &amp;quot;1&amp;quot;: 17493,
        &amp;quot;2&amp;quot;: 8746
    },
    &amp;quot;gate_types&amp;quot;: {
        &amp;quot;CNOT&amp;quot;: 8746,
        &amp;quot;Hadamard&amp;quot;: 4374,
        &amp;quot;QubitUnitary&amp;quot;: 13119
    },
    &amp;quot;gradient_fn&amp;quot;: &amp;quot;backprop&amp;quot;,
    &amp;quot;gradient_options&amp;quot;: {},
    &amp;quot;interface&amp;quot;: &amp;quot;autograd&amp;quot;,
    &amp;quot;num_device_wires&amp;quot;: 15,
    &amp;quot;num_diagonalizing_gates&amp;quot;: 0,
    &amp;quot;num_observables&amp;quot;: 1,
    &amp;quot;num_operations&amp;quot;: 26239,
    &amp;quot;num_trainable_params&amp;quot;: 13119,
    &amp;quot;num_used_wires&amp;quot;: 9
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This exercise shows how important ancilla qubits are. In some sense, they can store lots of information during quantum computations. I did not study this deeper, but it seemed that the circuit depth without ancilla qubits is growing fast, possibly exponentially.&lt;/p&gt;
&lt;h2 id=&#34;section-2-solution-proposal-with-ancilla-qubits&#34;&gt;Section 2: Solution proposal with ancilla qubits&lt;/h2&gt;
&lt;p&gt;If one studies the 14-control qubit MCX gate a bit, we can easily see that we can decompose it in the following manner. Also, the &lt;a href=&#34;https://algassert.com/circuits/2015/06/22/Using-Quantum-Gates-instead-of-Ancilla-Bits.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt; by Craig Gidney points out this. See the &lt;a href=&#34;https://algassert.com/quirk#circuit=%7b%22cols%22:[[%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,%22X%22],[1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22,%22%E2%80%A2%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,%22X%22]]%7d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quirk demonstration&lt;/a&gt; for 8 control-qubit Toffoli. The idea is that every ancilla qubit divides the construction into two MCX gates with half the number of the qubits as the original MCX gate.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;qr = QuantumRegister(14, &#39;ctrl&#39;)
target = QuantumRegister(1, &#39;target&#39;)
anc = QuantumRegister(1, &#39;ancilla&#39;)
circuit = QuantumCircuit(qr, target, anc)

gate7 = MCXGate(7)
gate8 = MCXGate(8)

controls7 = [qr[i] for i in range(7)]
controls8 = [qr[i] for i in range(7, 14)]

circuit.append(gate7, controls7 + [anc[0]])
circuit.append(gate8, controls8 + [anc[0], target[0]])
circuit.append(gate7, controls7 + [anc[0]])

circuit.draw(output=&#39;latex&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli8&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli8_huaca94def83fee83b0901f79dffa955e2_12316_2450c739a46fd8bebace91606324133c.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli8_huaca94def83fee83b0901f79dffa955e2_12316_d01e2b128271ac9a59e1965861041515.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli8_huaca94def83fee83b0901f79dffa955e2_12316_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli8_huaca94def83fee83b0901f79dffa955e2_12316_2450c739a46fd8bebace91606324133c.webp&#34;
               width=&#34;240&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&#34;https://algassert.com/quirk#circuit=%7b%22cols%22:[[%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,1,1,1,%22%E2%80%A2%22,1,1,1,1,1,1,1,%22X%22,%22%E2%80%A2%22],[1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,%22X%22],[1,1,1,1,1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,%22X%22],[1,1,1,1,1,1,1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,%22X%22],[1,1,1,1,1,1,1,1,1,1,1,1,%22X%22,%22%E2%80%A2%22],[1,1,1,1,1,1,1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,%22X%22],[1,1,1,1,1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,%22X%22],[1,1,1,1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,1,1,1,%22%E2%80%A2%22,1,1,1,1,1,1,1,%22X%22,%22%E2%80%A2%22],[1,1,1,%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,%22X%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,1,1,%22X%22],[1,1,%22%E2%80%A2%22,1,1,1,1,1,1,1,1,1,1,1,%22X%22]]%7d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quirk example for 12-qubit case&lt;/a&gt; when we use three ancilla qubits and Toffoli gates. Toffoli gates can be decomposed using the previous decompositions. Let&amp;rsquo;s code the above example with Pennylane:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math
n_ctrl = 14 # number of control qubits
target = n_ctrl + 1
dev = qml.device(&amp;quot;default.qubit&amp;quot;, wires=target)

@qml.qnode(dev)
def make_it_half(n_ctrl):
    target = n_ctrl
    ctrl_wires1 = list(range(math.ceil(n_ctrl/2)))
    ctrl_wires2 = list(range(math.floor(n_ctrl/2), n_ctrl)) + [target + 1]
    
    qml.MultiControlledX(control_wires = ctrl_wires1, wires = target + 1)
    qml.MultiControlledX(control_wires = ctrl_wires2, wires = target)
    qml.MultiControlledX(control_wires = ctrl_wires1, wires = target + 1)
    
    return qml.state()

qml.drawer.use_style(&#39;black_white&#39;)
fig, ax = qml.draw_mpl(make_it_half, wire_order=list(range(target)), show_all_wires = True)(n_ctrl)
fig.set_size_inches(fig.get_size_inches()[0]*0.3, fig.get_size_inches()[1]*0.3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we recursively replace &lt;code&gt;MultiControlledX&lt;/code&gt; until we have expressed everything in terms of Toffoli-gates:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dev = qml.device(&amp;quot;default.qubit&amp;quot;, wires=20)    

def make_it_half_recursive(ctrl_wires, target):
    n_ctrl = len(ctrl_wires)
    ctrl_indices1 = math.ceil(n_ctrl/2)
    
    if n_ctrl == 1:
        qml.Toffoli(wires = [ctrl_wires[0], target + 1, target])
    elif n_ctrl == 2:
        qml.Toffoli(wires = [ctrl_wires[0], ctrl_wires[1], target])
    else:
        new_target = max(max(ctrl_wires), target)
        make_it_half_recursive(ctrl_wires[:ctrl_indices1], new_target + 1)
        make_it_half_recursive(ctrl_wires[ctrl_indices1:] + [new_target + 1], target)
        make_it_half_recursive(ctrl_wires[:ctrl_indices1], new_target + 1)

@qml.qnode(dev)
def full_algorithm(ctrl_wires, target):
    make_it_half_recursive(ctrl_wires, target)
    return qml.state()

qml.drawer.use_style(&#39;black_white&#39;)
x = 14
fig, ax = qml.draw_mpl(full_algorithm, wire_order=list(range(20)), show_all_wires = False)(list(range(x)), x)
fig.set_size_inches(fig.get_size_inches()[0]*0.4, fig.get_size_inches()[1]*0.4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli9&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli9_hu6458cac32fa10a7450d2434e158298fe_50658_13b2ea61b2bab64e7b593e3de7de2df7.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli9_hu6458cac32fa10a7450d2434e158298fe_50658_c75771160f4b841341451156a6c6bf27.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli9_hu6458cac32fa10a7450d2434e158298fe_50658_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli9_hu6458cac32fa10a7450d2434e158298fe_50658_13b2ea61b2bab64e7b593e3de7de2df7.webp&#34;
               width=&#34;760&#34;
               height=&#34;296&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(&amp;quot;The specs of 14 control qubits MCX gate with ancilla qubits is: &amp;quot;)
print(json.dumps(qml.specs(full_algorithm)(list(range(14)), 14), indent=4, sort_keys=True))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;The specs of 14 control qubits MCX gate with ancilla qubits is: 
{
    &amp;quot;depth&amp;quot;: 33,
    &amp;quot;device_name&amp;quot;: &amp;quot;default.qubit.autograd&amp;quot;,
    &amp;quot;diff_method&amp;quot;: &amp;quot;best&amp;quot;,
    &amp;quot;expansion_strategy&amp;quot;: &amp;quot;gradient&amp;quot;,
    &amp;quot;gate_sizes&amp;quot;: {
        &amp;quot;3&amp;quot;: 49
    },
    &amp;quot;gate_types&amp;quot;: {
        &amp;quot;Toffoli&amp;quot;: 49
    },
    &amp;quot;gradient_fn&amp;quot;: &amp;quot;backprop&amp;quot;,
    &amp;quot;gradient_options&amp;quot;: {},
    &amp;quot;interface&amp;quot;: &amp;quot;autograd&amp;quot;,
    &amp;quot;num_device_wires&amp;quot;: 20,
    &amp;quot;num_diagonalizing_gates&amp;quot;: 0,
    &amp;quot;num_observables&amp;quot;: 1,
    &amp;quot;num_operations&amp;quot;: 49,
    &amp;quot;num_trainable_params&amp;quot;: 0,
    &amp;quot;num_used_wires&amp;quot;: 19
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we replace Toffoli-gates with the decomposition from the cell [6]:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def toffoli_decomposition(ctrl1, ctrl2, target):
    qml.Hadamard(wires = target)
    qml.CNOT(wires = [ctrl2, target])
    qml.adjoint(qml.T)(wires = target)
    qml.CNOT(wires=[ctrl1, target])
    qml.CNOT(wires=[ctrl1, ctrl2])
    qml.T(wires = target)
    qml.CNOT(wires=[ctrl2, target])
    qml.CNOT(wires=[ctrl1, target])
    qml.adjoint(qml.T)(wires = target)
    qml.adjoint(qml.T)(wires = ctrl2)
    qml.CNOT(wires=[ctrl1, target])
    qml.CNOT(wires=[ctrl1, ctrl2])
    qml.T(wires = target)
    qml.T(wires = ctrl1)
    qml.T(wires = ctrl2)
    qml.Hadamard(wires = target)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dev = qml.device(&amp;quot;default.qubit&amp;quot;, wires=19)
#dev = qml.device(&amp;quot;qiskit.aer&amp;quot;, wires=19)

def make_it_half_recursive_with_Toffoli_decomposition(ctrl_wires, target):
    n_ctrl = len(ctrl_wires)
    ctrl_indices1 = math.ceil(n_ctrl/2)
    
    if n_ctrl == 1:
        toffoli_decomposition(ctrl_wires[0], target + 1, target)
    elif n_ctrl == 2:
        toffoli_decomposition(ctrl_wires[0], ctrl_wires[1], target)
    else:
        new_target = max(max(ctrl_wires), target)
        make_it_half_recursive_with_Toffoli_decomposition(ctrl_wires[:ctrl_indices1], new_target + 1)
        make_it_half_recursive_with_Toffoli_decomposition(ctrl_wires[ctrl_indices1:] + [new_target + 1], target)
        make_it_half_recursive_with_Toffoli_decomposition(ctrl_wires[:ctrl_indices1], new_target + 1)

@qml.qnode(dev)
def final_full_algorithm(ctrl_wires, target):
    make_it_half_recursive_with_Toffoli_decomposition(ctrl_wires, target)
    return qml.expval(qml.PauliZ(0)) # We measure this because otherwise, the Qiskit plugin does not create correct OpenQASM

fig, ax = qml.draw_mpl(final_full_algorithm, wire_order=list(range(20)), show_all_wires = False)(list(range(14)), 14)
#fig.set_size_inches(fig.get_size_inches()[0]*0.4, fig.get_size_inches()[1]*0.4)
fig.savefig(&#39;final_circuit&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli10&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli10_hu6cbdb6dbc70657fda7da5140b1464a7e_503204_5c72d3c8c22abb27708cf56b7af53866.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli10_hu6cbdb6dbc70657fda7da5140b1464a7e_503204_1b7175d4a12a82d35ff4c92884f8cf6e.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli10_hu6cbdb6dbc70657fda7da5140b1464a7e_503204_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli10_hu6cbdb6dbc70657fda7da5140b1464a7e_503204_5c72d3c8c22abb27708cf56b7af53866.webp&#34;
               width=&#34;760&#34;
               height=&#34;30&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;To see the circuit correctly, see the final_circuit.png file. For some reason, the drawer gets lazy, and the end of the circuit is not precisely visible. Anyway, there are other options to draw it if necessary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(&amp;quot;The specs of 14 control qubits Toffoli gate with four ancilla qubits is: &amp;quot;)
print(json.dumps(qml.specs(final_full_algorithm)(list(range(14)), 14), indent=4, sort_keys=True))


# The following code generates OpenQASM for the circuit
# In this case, you need to run the circuit on qiskit.awr device since
# Pennylane does not support circuit conversion to OpenQASM

#final_full_algorithm(list(range(14)), 14)
#qasm_circuit = dev._circuit.qasm(formatted  = True, filename = &#39;toffoli_qasm&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;The specs of 14 control qubits Toffoli gate with four ancilla qubits is: 
{
    &amp;quot;depth&amp;quot;: 352,
    &amp;quot;device_name&amp;quot;: &amp;quot;default.qubit.autograd&amp;quot;,
    &amp;quot;diff_method&amp;quot;: &amp;quot;best&amp;quot;,
    &amp;quot;expansion_strategy&amp;quot;: &amp;quot;gradient&amp;quot;,
    &amp;quot;gate_sizes&amp;quot;: {
        &amp;quot;1&amp;quot;: 441,
        &amp;quot;2&amp;quot;: 343
    },
    &amp;quot;gate_types&amp;quot;: {
        &amp;quot;CNOT&amp;quot;: 343,
        &amp;quot;Hadamard&amp;quot;: 98,
        &amp;quot;T&amp;quot;: 196,
        &amp;quot;T.inv&amp;quot;: 147
    },
    &amp;quot;gradient_fn&amp;quot;: &amp;quot;backprop&amp;quot;,
    &amp;quot;gradient_options&amp;quot;: {},
    &amp;quot;interface&amp;quot;: &amp;quot;autograd&amp;quot;,
    &amp;quot;num_device_wires&amp;quot;: 19,
    &amp;quot;num_diagonalizing_gates&amp;quot;: 0,
    &amp;quot;num_observables&amp;quot;: 1,
    &amp;quot;num_operations&amp;quot;: 784,
    &amp;quot;num_trainable_params&amp;quot;: 0,
    &amp;quot;num_used_wires&amp;quot;: 19
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;testing-14-qubits-mcx-gate-with-ancilla-qubits&#34;&gt;Testing 14 qubits MCX gate with ancilla qubits&lt;/h3&gt;
&lt;p&gt;We test the code so that we create Hadamard transform over the 14 control qubits. We know that only one state (one containing 14 times $|1\rangle$) among $2^{14}$ produces output 1 when the target qubit is measured. This means that we should measure 1 from the target qubit with the probability $\frac{1}{2^{14}} = 1/16384 = 0.000061035... \approx 6.1035\times 10^{-5}$. Any mistake in the code will affect this probability.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dev = qml.device(&amp;quot;lightning.qubit&amp;quot;, wires=19)

@qml.qnode(dev)
def test_code(n):
    ctrl_wires, target = list(range(n)), n
    qml.broadcast(unitary=qml.Hadamard, pattern=&amp;quot;single&amp;quot;, wires=ctrl_wires)
    #qml.broadcast(unitary=qml.PauliX, pattern=&amp;quot;single&amp;quot;, wires=ctrl_wires)
    make_it_half_recursive_with_Toffoli_decomposition(ctrl_wires, target)
    return qml.probs(wires=[target])

print(test_code(14))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[9.99938965e-01 6.10351563e-05]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we see, the output probability of measuring 1 is close to &lt;code&gt;6.1035e-05&lt;/code&gt;. This indicates that the decomposition is correct.&lt;/p&gt;
&lt;h2 id=&#34;section-3-variational-classifier-eg-is-it-necessary-to-be-always-right&#34;&gt;Section 3: Variational classifier, e.g., is it necessary to be always right?&lt;/h2&gt;
&lt;p&gt;I think this exercise would be suitable and sufficiently simple for variational classifiers. So I modified the exercise to develop a parametrized quantum circuit optimized to simulate the MCX gate. It produces a correct value to the target qubit with a certain probability. The original idea of the variational classifier is demonstrated in &lt;a href=&#34;https://pennylane.ai/qml/demos/tutorial_variational_classifier.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pennylane&amp;rsquo;s demonstration&lt;/a&gt;, which is inspired by papers &lt;a href=&#34;https://arxiv.org/abs/1802.06002&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Classification with Quantum Neural Networks on Near Term Processors&lt;/a&gt; and &lt;a href=&#34;https://arxiv.org/abs/1804.00633&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Circuit-centric quantum classifiers&lt;/a&gt;. Now the gate depth and gate count depend on our ansatz.&lt;/p&gt;
&lt;p&gt;We can actually follow the outline of the demonstration. The demonstration implements a variational classifier for the parity function, but in our case, the function is quite simple too:

$$f \colon \left\{0,1 \right\}^{14} \to \left\{0,1 \right\}, \text{ where } f(x) = \begin{cases} 1 \text{ if } x_i = 1 \text{ for all } i = 1, \ldots 14 \\
0 \text{ otherwise}\end{cases}$$

There is plenty of data around now since we know precisely how MCX is supposed to work!&lt;/p&gt;
&lt;p&gt;I do not think I have the time and resources to train the model for 14 qubits MCX gate, so I demonstrate the problem with three control qubits and one target qubit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pennylane.optimize import AdamOptimizer

n_ctrl = 4
qubits = n_ctrl
dev = qml.device(&amp;quot;default.qubit&amp;quot;, wires=qubits)

def layer(W):
    for i in range(qubits - 1):
        qml.CRot(W[i, 0], W[i, 1], W[i, 2], wires = [i, qubits - 1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following circuit implements the ansatz for this quantum machine learning task. Some other sophisticated guesses might work better and have a shorter depth.
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;toffoli11&#34; srcset=&#34;
               /post/classiq_coding_competition_toffoli/toffoli11_hu12db9c5bcb59b6bc5117ad41fc80d512_18013_84b298e44ad60240e994b35604b5f043.webp 400w,
               /post/classiq_coding_competition_toffoli/toffoli11_hu12db9c5bcb59b6bc5117ad41fc80d512_18013_faa44c7e0c71963c589056c5c86f1ef7.webp 760w,
               /post/classiq_coding_competition_toffoli/toffoli11_hu12db9c5bcb59b6bc5117ad41fc80d512_18013_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://valteruo.github.io/post/classiq_coding_competition_toffoli/toffoli11_hu12db9c5bcb59b6bc5117ad41fc80d512_18013_84b298e44ad60240e994b35604b5f043.webp&#34;
               width=&#34;760&#34;
               height=&#34;115&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@qml.qnode(dev)
def MCToffoli(weights, x):
    
    qml.BasisState(x, wires=range(qubits - 1))

    for W in weights:
        layer(W)

    return qml.expval(qml.PauliZ(qubits - 1))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def variational_classifier(weights, bias, x):
    return MCToffoli(weights, x) #+ bias

def square_loss(labels, predictions):
    loss = 0
    for l, p in zip(labels, predictions):
        #print(&#39;Label &#39;, l, &#39; prediction &#39;, p)
        loss = loss + (l - p) ** 2

    loss = loss / len(labels)
    return loss


def accuracy(labels, predictions):
    loss = 0
    for l, p in zip(labels, predictions):
        if abs(l - p) &amp;lt; 1e-5:
            loss = loss + 1
    loss = loss / len(labels)

    return loss


def cost(weights, bias, X, Y):
    predictions = [variational_classifier(weights, bias, x) for x in X]
    return square_loss(Y, predictions)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following code generates the training data. Since we know how the function works, we can easily generate as much data as we need:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from itertools import combinations
b_strings = []

def genbin(n, bs = []):
    if n-1:
        genbin(n-1, bs + [0])
        genbin(n-1, bs + [1])
    else:
        b_strings.append([1] + bs)
        b_strings.append([0] + bs)

def generate_data(n_items, qubits):
    result = [1 for i in range(qubits-1)]
    Y = [0]
    X = [result]
    
    genbin(qubits-1)
    
    for string in b_strings:
        if not all(string):
            X.append(string)
            Y.append(1)
        
    return np.array(X, requires_grad=False), np.array(Y, requires_grad=False)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n_items = 2^qubits
X, Y = generate_data(n_items, qubits)
Y = Y * 2 - np.ones(len(Y))  # shift label from {0, 1} to {-1, 1}

print(&amp;quot;Example of generated data: &amp;quot;)
for i in range(5):
    print(&amp;quot;X = {}, Y = {: d}&amp;quot;.format(X[i], int(Y[i])))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Example of generated data: 
X = [1 1 1], Y = -1
X = [1 0 0], Y =  1
X = [0 0 0], Y =  1
X = [1 0 1], Y =  1
X = [0 0 1], Y =  1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Training process:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;np.random.seed(0)
num_qubits = qubits
num_layers = 10
weights_init = 0.01 * np.random.randn(num_layers, num_qubits, 3, requires_grad=True)
bias_init = np.array(0.0, requires_grad=True)

opt = AdamOptimizer()
batch_size = 5
weights = weights_init
bias = bias_init
for it in range(100):

    # Update the weights by one optimizer step
    batch_index = np.random.randint(0, len(X), (batch_size,))
    X_batch = X[batch_index]
    Y_batch = Y[batch_index]
    weights, bias, _, _ = opt.step(cost, weights, bias, X_batch, Y_batch)

    # Compute accuracy
    predictions = [np.sign(variational_classifier(weights, bias, x)) for x in X]
    acc = accuracy(Y, predictions)

    print(
        &amp;quot;Iter: {:5d} | Cost: {:0.7f} | Accuracy: {:0.7f} &amp;quot;.format(
            it + 1, cost(weights, bias, X, Y), acc
        )
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Iter:     1 | Cost: 0.4599114 | Accuracy: 0.8750000 
Iter:     2 | Cost: 0.4238353 | Accuracy: 0.8750000 
Iter:     3 | Cost: 0.3598879 | Accuracy: 0.8750000 
Iter:     4 | Cost: 0.3144206 | Accuracy: 0.8750000 
Iter:     5 | Cost: 0.2946587 | Accuracy: 0.8750000 
Iter:     6 | Cost: 0.2882779 | Accuracy: 0.8750000 
Iter:     7 | Cost: 0.2879778 | Accuracy: 0.8750000 
Iter:     8 | Cost: 0.2991846 | Accuracy: 0.8750000 
Iter:     9 | Cost: 0.3251705 | Accuracy: 0.8750000 
Iter:    10 | Cost: 0.3131737 | Accuracy: 0.8750000 
...
Iter:    98 | Cost: 0.0158998 | Accuracy: 1.0000000 
Iter:    99 | Cost: 0.0157305 | Accuracy: 1.0000000 
Iter:   100 | Cost: 0.0155114 | Accuracy: 1.0000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We create the same circuit as we used in the model except that we measure the target qubit&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@qml.qnode(dev)
def MCToffoli2(weights, x):
    
    qml.BasisState(x, wires=range(qubits - 1))

    for W in weights:
        layer(W)

    return qml.probs(wires=qubits - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If any of the three control qubits is 0, we measure 0 with high probability:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = np.array([0,0,0])
print(MCToffoli2(weights, x))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[1. 0.]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If all three control qubits are 1, we measure 1 with high probability:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = np.array([1,1,1])
print(MCToffoli2(weights, x))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[0.09396188 0.90603812]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conclusion-and-lessons-to-learn&#34;&gt;Conclusion and lessons to learn&lt;/h2&gt;
&lt;p&gt;Although these decompositions did not contain very many T-gates, there is &lt;a href=&#34;https://arxiv.org/abs/1903.10477&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;interesting research&lt;/a&gt; studying T-count reduction with &lt;a href=&#34;https://zxcalculus.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ZX-calculus&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The most interesting lesson I learned was the remarkable effect of ancilla qubits. Of course, I knew that many decompositions require ancilla qubits. Still, I have never had first-hand experience in recognizing the actual difference in circuit depth in cases we do not use ancilla qubits vs. we use them.&lt;/p&gt;
&lt;p&gt;Secondly, the quantum machine learning approach seems an exciting option, and in my opinion, it demonstrates how well ML and quantum computing fit together. In the near future, we will see a lot of quantum machine learning applications.&lt;/p&gt;
&lt;p&gt;The gate count in these solutions was not sufficiently good if you compare them to the winning solutions. I am happy that Classiq considered the first decompositions as valid solutions to the problem (the ML approach was not valid since the output was not exactly correct).&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/valterUo/classiq-coding-competition/blob/main/toffoli.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jupyter notebook&lt;/a&gt; contains the code in this blog post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Research in Intersection of Quantum Computing And Databases</title>
      <link>https://valteruo.github.io/post/initial-post/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://valteruo.github.io/post/initial-post/</guid>
      <description>&lt;p&gt;Welcome to my academic webpage! Since the biography in the beginning is good to keep short, I explain my academic interests and motivate my research deeper in this post. I started as a Ph.D. student in April 2022 at the University of Helsinki in the computer science department in the &lt;a href=&#34;https://www2.helsinki.fi/en/researchgroups/unified-database-management-systems-udbms&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Unified Database Management Systems research group&lt;/a&gt;. Before my Ph.D. studies, I worked as a research assistant in the same group.&lt;/p&gt;
&lt;p&gt;If you check my previous publications, I have not been researching quantum computing but applications of category theory for multi-model databases. Usually, a relatively small science community can understand your research specifically. In my case, I felt that the community was even smaller than usual. Understandably, the database research community is not familiar with applied category theory. On the other hand, the results were not very deep from a category theory point of view. Although applied category theory is exciting and topical, I noticed that category theory and databases are relatively narrow research topics.&lt;/p&gt;
&lt;p&gt;I have studied special linear algebraic topics in my thesis, e.g., quadratic forms and Pfister forms. After all, quadratic and Pfister forms are matrices, and their manipulation requires advanced algebraic results. Because quantum computing is theoretically based on linear algebraic structures, I can relatively easily apply my previous knowledge and adopt quantum computing in my research. I have not officially studied quantum computing because our university had only a single quantum computing course, and I did not find it in my student times. Our department has plans to extend quantum computing teaching, which is a very positive direction. I believe that I will surely be a part of the development of education.&lt;/p&gt;
&lt;p&gt;I do not believe that quantum computing will bring immersive computational speedups in the near future. In terms of speed, the promises of quantum computing are sometimes over-hyped. When I represent my research, I aim to be realistic regarding its possibilities. On the other hand, time is just a single &amp;lsquo;&amp;lsquo;parameter&amp;rsquo;&amp;rsquo; that we want to minimize. Sometimes we should move our focus away from time efficiency. Whereas we can keep arguing if quantum computing can perform faster than classical, we can be sure that quantum computing is much more &lt;em&gt;energy&lt;/em&gt; efficient than classical. We have read news about bitcoin mining which consumes a tremendous amount of energy, and the data centers require their own nuclear powerplants before their energy consumption is covered. Energy will be literary a disappearing resource in the world. Also, we are currently living in the very last moments when we can still do something against the climate crisis. Here, quantum computers can save a part of the field because their energy consumption is at the level of your fridge at home. Sometimes you might want to trade speed with energy.&lt;/p&gt;
&lt;p&gt;The second motivation to add quantum computing along with databases and category theory is the conceptual model. Quantum computing is a fundamentally different computing model. Learning to think &lt;em&gt;quantumly&lt;/em&gt; is a fascinating (and very long) journey! Quantum computing is intriguing, even if we never find any serious applications for it.&lt;/p&gt;
&lt;p&gt;How can we apply quantum computing in data management? That is my research&amp;rsquo;s core question, and the possible ideas deserve their own post. I have written a detailed Ph.D. workshop paper for VLDB 2022 conference. If it gets accepted, I will link it here. Anyway, I want to point out that I want to continue researching the possibilities of category theory in the context of quantum computing and databases. There is already extensive research connecting category theory and quantum computing. The pioneer of the field is &lt;a href=&#34;https://scholar.google.fi/citations?user=fO17CXgAAAAJ&amp;amp;hl=fi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bob Coecke&lt;/a&gt;. Research linking quantum computing and databases is still in its initial steps, and as far as I know, the database community is not aware of its possibilities.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
